# Laravel 9 · Сессия HTTP

- [Введение](#introduction)
    - [Конфигурирование](#configuration)
    - [Предварительная подготовка драйверов](#driver-prerequisites)
- [Взаимодействие с сессией](#interacting-with-the-session)
    - [Получение данных](#retrieving-data)
    - [Сохранение данных](#storing-data)
    - [Кратковременные данные](#flash-data)
    - [Удаление данных](#deleting-data)
    - [Пересоздание идентификатора сессии](#regenerating-the-session-id)
- [Блокировка сессии](#session-blocking)
- [Добавление собственных драйверов сессии](#adding-custom-session-drivers)
    - [Реализация пользовательского драйвера](#implementing-the-driver)
    - [Регистрация пользовательского драйвера](#registering-the-driver)

<a name="introduction"></a>
## Введение

Поскольку приложения, использующие HTTP, не имеют состояния, то сессии позволяют хранить пользовательскую информацию между несколькими запросами. Эта пользовательская информация обычно помещается в постоянное хранилище, к которому можно получить доступ из последующих запросов.

Laravel предлагает множество различных типов хранилищ сессий, доступ к которым осуществляется через выразительный унифицированный API. Осуществлена поддержка популярных типов хранилищ, таких как [Memcached](https://memcached.org), [Redis](https://redis.io) и база данных.

<a name="configuration"></a>
### Конфигурирование

Конфигурационный файл сессии вашего приложения расположен в `config/session.php`. Обязательно просмотрите параметры, доступные вам в этом файле. По умолчанию Laravel ориентирован на использование драйвера `file` сессии, который подходит для многих приложений. Если ваше приложение будет балансировать нагрузку между несколькими веб-серверами, то вам следует выбрать централизованное хранилище, к которому могут получить доступ все серверы, например Redis или база данных.

Параметр конфигурации `driver` сессии определяет, где будут храниться данные сессии для каждого запроса. Laravel содержит несколько отличных драйверов из коробки:

<!-- <div class="content-list" markdown="1"> -->

- `file` – сессии хранятся в `storage/framework/sessions`.
- `cookie` – сессии хранятся в безопасных, зашифрованных файлах Cookies.
- `database` – сессии хранятся в реляционной базе данных.
- `memcached` / `redis` – сессии хранятся в одном из этих быстрых хранилищ на основе кеша.
- `dynamodb` – сессии хранятся в AWS DynamoDB.
- `array` – сессии хранятся в массиве PHP и не будет сохранены.

<!-- </div> -->

> {tip} Драйвер `array` в основном используется во время [тестирования](testing.md) и предотвращает сохранение данных, находящихся в сессии.

<a name="driver-prerequisites"></a>
### Предварительная подготовка драйверов

<a name="database"></a>
#### Драйвер `database`

При использовании драйвера `database` сессии, вам нужно будет создать таблицу, содержащую записи сессии. Пример объявления `Schema` для таблицы ниже:

    Schema::create('sessions', function ($table) {
        $table->string('id')->primary();
        $table->foreignId('user_id')->nullable()->index();
        $table->string('ip_address', 45)->nullable();
        $table->text('user_agent')->nullable();
        $table->text('payload');
        $table->integer('last_activity')->index();
    });

Вы можете использовать команду `session:table` Artisan для генерации этой миграции. Чтобы узнать больше о миграции баз данных, вы можете ознакомиться с полной [документацией по миграции](migrations.md):

```shell
php artisan session:table

php artisan migrate
```

<a name="redis"></a>
#### Redis

Перед использованием Redis с Laravel вам нужно будет либо установить расширение PHP PhpRedis через PECL, либо установить пакет `predis/predis` (~ 1.0) через Composer. Для получения дополнительной информации о настройке Redis обратитесь к [документации Redis](redis.md#configuration) Laravel.

> {tip} В параметре `connection` конфигурационного файла `config/session.php` указывается, какое соединение Redis используется сессией.

<a name="interacting-with-the-session"></a>
## Взаимодействие с сессией

<a name="retrieving-data"></a>
### Получение данных

В Laravel есть два основных способа работы с данными сессии: через глобальный помощник `session` или через экземпляр `Request`. Во-первых, давайте посмотрим на доступ к сессии через экземпляр `Request`, тип которого может быть объявлен в замыкании маршрута или методе контроллера. Помните, что зависимости методов контроллера автоматически внедряются через [контейнер служб](container.md) Laravel:

    <?php

    namespace App\Http\Controllers;

    use App\Http\Controllers\Controller;
    use Illuminate\Http\Request;

    class UserController extends Controller
    {
        /**
         * Показать профиль конкретного пользователя.
         *
         * @param  Request  $request
         * @param  int  $id
         * @return Response
         */
        public function show(Request $request, $id)
        {
            $value = $request->session()->get('key');

            //
        }
    }

Когда вы извлекаете элемент из сессии, вы также можете передать значение по умолчанию в качестве второго аргумента метода `get`. Это значение по умолчанию будет возвращено, если указанный ключ не существует в сессии. Если вы передаете замыкание в качестве значения по умолчанию методу `get`, а запрошенный ключ не существует, то будет выполнено замыкание с последующим возвратом его результата:

    $value = $request->session()->get('key', 'default');

    $value = $request->session()->get('key', function () {
        return 'default';
    });

<a name="the-global-session-helper"></a>
#### Глобальный помощник `session`

Вы также можете использовать глобальную помощник `session` для получения / сохранения данных сессии. Когда помощник `session` вызывается с одним строковым аргументом, тогда он возвращает значение этого ключа сессии. Когда помощник вызывается с массивом пар ключ / значение, эти значения сохраняются в сессию:

    Route::get('/home', function () {
        // Получить часть данных из сессии ...
        $value = session('key');

        // Получить часть данных из сессии с указанием значения по умолчанию ...
        $value = session('key', 'default');

        // Сохранить часть данных в сессию ...
        session(['key' => 'value']);
    });

> {tip} Существует небольшая практическая разница между использованием сессии через экземпляр HTTP-запроса и использованием глобального помощника `session`. Оба метода [тестируемые](testing.md) с помощью метода `assertSessionHas`, который доступен во всех ваших тестах.

<a name="retrieving-all-session-data"></a>
#### Получение всех данных сессии

Если вы хотите получить все данные сессии, то вы можете использовать метод `all`:

    $data = $request->session()->all();

<a name="determining-if-an-item-exists-in-the-session"></a>
#### Определение наличия элемента в сессии

Чтобы определить, присутствует ли элемент в сессии, вы можете использовать метод `has`. Метод `has` возвращает `true`, если элемент присутствует, и не равен `null`:

    if ($request->session()->has('users')) {
        //
    }

Чтобы определить, присутствует ли элемент в сессии, даже если его значение равно `null`, то вы можете использовать метод `exists`:

    if ($request->session()->exists('users')) {
        //
    }

Чтобы определить отсутствие элемента в сессии, вы можете использовать метод `missing`. Метод `missing` возвращает `true`, если элемент отсутствует или если он равен `null`:

    if ($request->session()->missing('users')) {
        //
    }

<a name="storing-data"></a>
### Сохранение данных

Для сохранения данных в сессии вы обычно будете использовать метод `put` экземпляра запроса или глобального помощника `session`:

    // Через экземпляр запроса ...
    $request->session()->put('key', 'value');

    // Через глобальный помощник «session» ...
    session(['key' => 'value']);

<a name="pushing-to-array-session-values"></a>
#### Добавление в массив значений сессии

Метод `push` используется для вставки нового значения в значение сессии, которое является массивом. Например, если ключ `user.teams` содержит массив названий команд, то вы можете поместить новое значение в массив следующим образом:

    $request->session()->push('user.teams', 'developers');

<a name="retrieving-deleting-an-item"></a>
#### Получение с последующим удалением элемента

Метод `pull` извлекает и удаляет элемент из сессии единым выражением:

    $value = $request->session()->pull('key', 'default');

<a name="#incrementing-and-decrementing-session-values"></a>
#### Увеличение и уменьшение отдельных значений в сессии

Если данные вашей сессии содержат целое число, которое вы хотите увеличить или уменьшить, то вы можете использовать методы `increment` и `decrement`:

    $request->session()->increment('count');

    $request->session()->increment('count', $incrementBy = 2);

    $request->session()->decrement('count');

    $request->session()->decrement('count', $decrementBy = 2);

<a name="flash-data"></a>
### Кратковременные данные

По желанию можно сохранить элементы в сессии только для следующего запроса. Вы можете сделать это с помощью метода `flash`. Данные, хранящиеся в сессии с использованием этого метода, будут доступны немедленно и во время следующего HTTP-запроса. После следующего HTTP-запроса данные будут удалены. Кратковременные данные в первую очередь полезны для краткосрочных статусных сообщений:

    $request->session()->flash('status', 'Task was successful!');

Если вам нужно сохранить кратковременные данные для нескольких запросов, то вы можете использовать метод `reflash`, который сохранит все данные для дополнительного запроса. Если вам нужно сохранить конкретные кратковременные данные, то вы можете использовать метод `keep`:

    $request->session()->reflash();

    $request->session()->keep(['username', 'email']);

Чтобы сохранить ваши кратковременные данные только для текущего запроса, вы можете использовать метод `now`:

    $request->session()->now('status', 'Task was successful!');

<a name="deleting-data"></a>
### Удаление данных

Метод `forget` удалит часть данных из сессии. Если вы хотите удалить все данные из сессии, то вы можете использовать метод `flush`:

    // Удалить единственный ключ ...
    $request->session()->forget('name');

    // Удалить несколько ключей ...
    $request->session()->forget(['name', 'status']);

    $request->session()->flush();

<a name="regenerating-the-session-id"></a>
### Пересоздание идентификатора сессии

Пересоздание идентификатора сессии зачастую выполняется для предотвращения использования злоумышленниками атак с [фиксацией сессии](https://owasp.org/www-community/attacks/Session_fixation) в отношении вашего приложения.

Laravel автоматически пересоздает идентификатор сессии во время аутентификации, если вы используете один из [стартовых комплектов приложений](starter-kits.md) Laravel или [Laravel Fortify](fortify.md); однако, если вам необходимо вручную повторно сгенерировать идентификатор сессии, то вы можете использовать метод `regenerate`:

    $request->session()->regenerate();

Если вам нужно повторно сгенерировать идентификатор сессии и удалить все данные из нее одним выражением, то вы можете использовать метод `invalidate`:

    $request->session()->invalidate();

<a name="session-blocking"></a>
## Блокировка сессии

> {note} Чтобы использовать блокировку сессии, ваше приложение должно использовать драйвер кеша с поддержкой [атомарных блокировок](cache.md#atomic-locks). В настоящее время этими драйверами кеширования являются `memcached`, `dynamodb`, `redis` и `database`. Кроме того, вы не можете использовать драйвер сессии `cookie`.

По умолчанию Laravel позволяет конкурентное выполнение запросов, использующих одну и ту же сессию. Так, например, если вы используете HTTP-библиотеку JavaScript для выполнения двух HTTP-запросов к вашему приложению, то они оба будут выполняться одновременно. Для многих приложений это не проблема; однако в некоторых приложениях, выполняющих запросы с записью данных в сессию и к двум различным конечным точкам приложения, может произойти потеря данных сессии.

Чтобы смягчить это, Laravel предлагает функциональность, которая позволяет ограничивать количество одновременных запросов для текущей сессии. Для начала вы можете просто привязать метод `block` к определению вашего маршрута. В этом примере входящий запрос к конечной точке `/profile` получит блокировку сессии. Пока эта блокировка удерживается, любые входящие запросы к конечным точкам `/profile` или `/order` с одним и тем же идентификатором сессии будут ждать завершения выполнения первого запроса, прежде чем они будут выполнены:

    Route::post('/profile', function () {
        //
    })->block($lockSeconds = 10, $waitSeconds = 10)

    Route::post('/order', function () {
        //
    })->block($lockSeconds = 10, $waitSeconds = 10)

Метод `block` принимает два необязательных аргумента. Первый аргумент, принимаемый методом `block` – это максимальное количество секунд, в течение которых блокировка сессии должна удерживаться, прежде чем она будет снята. Конечно, если выполнение запроса завершится до этого времени, блокировка будет снята раньше.

Второй аргумент, принимаемый методом `block` – это количество секунд, в течение которых запрос должен ждать при попытке получить блокировку сессии. Если запрос не сможет получить блокировку сессии в течение указанного количества секунд, то будет выброшено исключение `Illuminate\Contracts\Cache\LockTimeoutException`.

Если ни один из этих аргументов не передан, то блокировка будет получена максимум на `10` секунд, а запросы будут ждать максимум `10` секунд при попытке получить блокировку:

    Route::post('/profile', function () {
        //
    })->block()

<a name="adding-custom-session-drivers"></a>
## Добавление собственных драйверов сессии

<a name="implementing-the-driver"></a>
#### Реализация пользовательского драйвера

Если ни один из существующих драйверов сессии не соответствует потребностям вашего приложения, то Laravel позволяет написать собственный обработчик сессии. Ваш собственный драйвер сессии должен реализовывать `SessionHandlerInterface`, встроенный в PHP. Этот интерфейс содержит всего несколько простых методов. Заготовка реализация MongoDB выглядит следующим образом:

    <?php

    namespace App\Extensions;

    class MongoSessionHandler implements \SessionHandlerInterface
    {
        public function open($savePath, $sessionName) {}
        public function close() {}
        public function read($sessionId) {}
        public function write($sessionId, $data) {}
        public function destroy($sessionId) {}
        public function gc($lifetime) {}
    }

> {tip} Laravel не содержит каталога для хранения ваших расширений. Вы можете разместить их где угодно. В этом примере мы создали каталог `Extensions` для размещения `MongoSessionHandler`.

Поскольку цель этих методов не совсем понятна, давайте быстро рассмотрим, что делает каждый из этих методов:

<!-- <div class="content-list" markdown="1"> -->

- Метод `open` обычно используется в файловых системах хранения сессии. Поскольку Laravel поставляется с драйвером `file` сессии, за редким исключением вам понадобится что-либо вставлять в этот метод. Вы можете просто оставить этот метод пустым.
- Метод `close`, как и метод `open`, также обычно не учитывается. Для большинства драйверов в этом нет необходимости.
- Метод `read` должен возвращать строковую версию данных сессии, связанных с переданным `$sessionId`. Нет необходимости выполнять сериализацию или другое кодирование при получении или хранении данных сессии в вашем драйвере, поскольку Laravel выполнит сериализацию за вас.
- Метод `write` должен записать переданную строку `$data`, связанную с `$sessionId`, в какую-нибудь постоянную систему хранения, такую как MongoDB или другую систему хранения по вашему выбору. Опять же, вам не следует выполнять сериализацию – Laravel сделает это за вас.
- Метод `destroy` должен удалить данные, связанные с `$sessionId` из постоянного хранилища.
- Метод `gc` должен уничтожить все данные сессии, которые старше указанного `$lifetime`, которое является временной меткой UNIX. Для самоуничтожающихся систем, таких как Memcached и Redis, этот метод можно оставить пустым.

<!-- </div> -->

<a name="registering-the-driver"></a>
#### Регистрация пользовательского драйвера

Как только ваш драйвер будет реализован, вы готовы зарегистрировать его в Laravel. Чтобы добавить дополнительные драйверы в серверную часть сессии Laravel, вы можете использовать метод `extend` [фасада](facades.md) `Session`. Вы должны вызвать метод `extend` в методе `boot` [поставщика службы](providers.md). Вы можете сделать это в уже существующем `App\Providers\AppServiceProvider` или создать совершенно новый поставщик:

    <?php

    namespace App\Providers;

    use App\Extensions\MongoSessionHandler;
    use Illuminate\Support\Facades\Session;
    use Illuminate\Support\ServiceProvider;

    class SessionServiceProvider extends ServiceProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            Session::extend('mongo', function ($app) {
                // Return an implementation of SessionHandlerInterface...
                return new MongoSessionHandler;
            });
        }
    }

После регистрации драйвера сессии вы можете использовать драйвер `mongo` в конфигурационном файле `config/session.php`.
