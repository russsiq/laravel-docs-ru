# Маршрутизация

- [Базовая маршрутизация](#basic-routing)
    - [Маршруты перенаправлений](#redirect-routes)
    - [Маршруты представлений](#view-routes)
- [Параметры маршрута](#route-parameters)
    - [Обязательные параметры](#required-parameters)
    - [Непостоянные параметры](#parameters-optional-parameters)
    - [Ограничения регулярного выражения](#parameters-regular-expression-constraints)
- [Именованные маршруты](#named-routes)
- [Группы маршрутов](#route-groups)
    - [Посредники](#route-group-middleware)
    - [Маршрутизация поддоменов](#route-group-subdomain-routing)
    - [Префиксы URI сгруппированных маршрутов](#route-group-prefixes)
    - [Префиксы имен сгруппированных маршрутов](#route-group-name-prefixes)
- [Привязка модели к маршруту](#route-model-binding)
    - [Неявная привязка](#implicit-binding)
    - [Явная привязка](#explicit-binding)
- [Резервные маршруты](#fallback-routes)
- [Ограничение количества запросов](#rate-limiting)
    - [Определение ограничителей количества запросов](#defining-rate-limiters)
    - [Привязка ограничителей количества запросов к маршрутам](#attaching-rate-limiters-to-routes)
- [Подмена методов формы](#form-method-spoofing)
- [Доступ к текущему маршруту](#accessing-the-current-route)
- [Совместное использование ресурсов между источниками (CORS)](#cors)
- [Кэширование маршрутов](#route-caching)

<a name="basic-routing"></a>
## Базовая маршрутизация

Простейшие маршруты Laravel принимают URI и замыкание, обеспечивая нетрудоемкий и выразительный метод определения маршрутов и поведения без сложных файлов конфигурации маршрутизации:

    use Illuminate\Support\Facades\Route;

    Route::get('/greeting', function () {
        return 'Hello World';
    });

<a name="the-default-route-files"></a>
#### Файлы маршрутов по умолчанию

Все маршруты Laravel определены в ваших файлах маршрутов, которые находятся в каталоге `routes`. Эти файлы автоматически загружаются вашим поставщиком `App\Providers\RouteServiceProvider` приложения. Файл `routes/web.php` определяет маршруты для вашего веб-интерфейса. Этим маршрутам назначается группа посредников `web`, которая обеспечивает такие функции, как состояние сессии и защита от CSRF. Маршруты в `routes/api.php` не сохраняют состояния и им назначается группа посредников `api`.

Для большинства приложений вы начнете с определения маршрутов в файле `routes/web.php`. К маршрутам, определенным в `routes/web.php`, можно получить доступ, введя URL-адрес определенного маршрута в вашем браузере. Например, вы можете получить доступ к следующему маршруту, перейдя по адресу `http://example.com/user` в своем браузере:

    use App\Http\Controllers\UserController;

    Route::get('/user', [UserController::class, 'index']);

Маршруты, определенные в файле `routes/api.php`, вложены в группу маршрутов в `RouteServiceProvider`. Внутри этой группы автоматически применяется префикс URI `/api`, поэтому вам не нужно вручную добавлять его к каждому маршруту в файле. Вы можете изменить префикс и другие параметры группы маршрутов, изменив свой класс `RouteServiceProvider`.

<a name="available-router-methods"></a>
#### Доступные методы маршрутизатора

Маршрутизатор позволяет регистрировать маршруты, отвечающие на любой HTTP-метод:

    Route::get($uri, $callback);
    Route::post($uri, $callback);
    Route::put($uri, $callback);
    Route::patch($uri, $callback);
    Route::delete($uri, $callback);
    Route::options($uri, $callback);

Иногда вам может потребоваться зарегистрировать маршрут, отвечающий на несколько HTTP-методов. Вы можете сделать это с помощью метода `match`. Или вы даже можете зарегистрировать маршрут, отвечающий на все HTTP-методы, используя метод `any`:

    Route::match(['get', 'post'], '/', function () {
        //
    });

    Route::any('/', function () {
        //
    });

<a name="dependency-injection"></a>
#### Внедрение зависимости

Вы можете объявить любые зависимости, необходимые для вашего маршрута, в сигнатуре замыкания вашего маршрута. Объявленные зависимости будут автоматически извлечены и внедрены в замыкание с помощью [контейнера служб](container.md) Laravel. Например, вы можете объявить класс `Illuminate\Http\Request`, чтобы текущий HTTP-запрос автоматически был внедрен в замыкание вашего маршрута:

    use Illuminate\Http\Request;

    Route::get('/users', function (Request $request) {
        // ...
    });

<a name="csrf-protection"></a>
#### Защита от CSRF

Помните, что любые HTML-формы, указывающие на маршруты `POST`, `PUT`, `PATCH` или `DELETE`, которые определены в файле маршрутов `web`, должны включать поле токена CSRF. В противном случае запрос будет отклонен. Вы можете прочитать больше о защите jn CSRF в [документации CSRF](csrf.md):

    <form method="POST" action="/profile">
        @csrf
        ...
    </form>

<a name="redirect-routes"></a>
### Маршруты перенаправлений

Если вы определяете маршрут, который перенаправляет на другой URI, вы можете использовать метод `Route::redirect`. Этот метод имеет лаконичную запись, так что вам не нужно определять полный маршрут или контроллер для выполнения простого перенаправления:

    Route::redirect('/here', '/there');

По умолчанию `Route::redirect` возвращает код состояния `302`. Вы можете переопределить код состояния, используя необязательный третий параметр:

    Route::redirect('/here', '/there', 301);

Или вы можете использовать метод `Route::permanentRedirect` для возврата кода состояния `301`:

    Route::permanentRedirect('/here', '/there');

> {note} При использовании параметров маршрута в маршрутах перенаправления, следующие параметры зарезервированы Laravel и не могут быть использованы: `destination` и `status`.

<a name="view-routes"></a>
### Маршруты представлений

Если ваш маршрут должен возвращать только [HTML-шаблон](views.md), вы можете использовать метод `Route::view`. Как и метод `redirect`, этот метод имеет лаконичную запись, так что вам не нужно определять полный маршрут или контроллер. Метод `view` принимает URI в качестве первого аргумента и имя шаблона в качестве второго аргумента. Кроме того, вы можете предоставить массив данных для передачи в шаблон в качестве необязательного третьего аргумента:

    Route::view('/welcome', 'welcome');

    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

> {note} При использовании параметров маршрута в маршрутах представлений, следующие параметры зарезервированы Laravel и не могут быть использованы: `view`, `data`, `status` и `headers`.

<a name="route-parameters"></a>
## Параметры маршрута

<a name="required-parameters"></a>
### Обязательные параметры

Иногда вам нужно будет отследить сегменты URI в вашем маршруте. Например, вам может потребоваться отследить идентификатор пользователя из URL-адреса. Вы можете сделать это, указав параметры маршрута:

    Route::get('/user/{id}', function ($id) {
        return 'User '.$id;
    });

Вы можете определить столько параметров маршрута, сколько требуется для вашего маршрута:

    Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {
        //
    });

Параметры маршрута всегда заключаются в фигурные скобки `{}` и должны состоять из буквенных символов. Подчеркивание (`_`) также допускается в именах параметров маршрута. Параметры маршрута будут внедрены в замыкания маршрута / контроллеры в зависимости от их порядка, т.е. имена аргументов замыкания маршрута / контроллера не имеют значения.

<a name="parameters-and-dependency-injection"></a>
#### Параметры и внедрение зависимости

Если у вашего маршрута есть зависимости, которые вы хотите, чтобы контейнер служб Laravel автоматически внедрял в замыкание вашего маршрута, вы должны указать необходимые параметры маршрута **после** указания этих зависимостей:

    use Illuminate\Http\Request;

    Route::get('/user/{id}', function (Request $request, $id) {
        return 'User '.$id;
    });

<a name="parameters-optional-parameters"></a>
### Непостоянные параметры

Иногда может потребоваться указать параметр маршрута, который не всегда может присутствовать в URI. Вы можете сделать это, поставив знак `?` после имени параметра. Не забудьте присвоить соответствующей переменной маршрута значение по умолчанию:

    Route::get('/user/{name?}', function ($name = null) {
        return $name;
    });

    Route::get('/user/{name?}', function ($name = 'John') {
        return $name;
    });

<a name="parameters-regular-expression-constraints"></a>
### Ограничения регулярного выражения

Вы можете ограничить формат параметров вашего маршрута, используя метод `where` экземпляра маршрута. Метод `where` принимает имя параметра и регулярное выражение, определяющее, как параметр должен быть ограничен:

    Route::get('/user/{name}', function ($name) {
        //
    })->where('name', '[A-Za-z]+');

    Route::get('/user/{id}', function ($id) {
        //
    })->where('id', '[0-9]+');

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Для некоторых часто используемых шаблонов регулярных выражений есть соответствующие вспомогательные методы, позволяющие быстро добавлять их к вашим маршрутам:

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->whereNumber('id')->whereAlpha('name');

    Route::get('/user/{name}', function ($name) {
        //
    })->whereAlphaNumeric('name');

    Route::get('/user/{id}', function ($id) {
        //
    })->whereUuid('id');

Если входящий запрос не соответствует ограничениям шаблона маршрута, будет возвращен HTTP-ответ `404`.

<a name="parameters-global-constraints"></a>
#### Глобальные ограничения

Если вы хотите, чтобы параметр маршрута всегда ограничивался конкретным регулярным выражением, вы можете использовать метод `pattern`. Вы должны определить эти шаблоны в методе `boot` вашего класса `App\Providers\RouteServiceProvider`:

    /**
     * Определить связывание модели и маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

Как только шаблон определен, он автоматически применяется ко всем маршрутам, использующим это имя параметра:

    Route::get('/user/{id}', function ($id) {
        // Выполнится, только если параметр `{id}` имеет числовое значение ...
    });

<a name="parameters-encoded-forward-slashes"></a>
#### Кодирование обратных слешей

Компонент маршрутизации Laravel позволяет всем символам, кроме `/`, присутствовать в значениях параметров маршрута. Вы должны явно разрешить `/` быть частью вашего заполнителя, используя регулярное выражение условия `where`:

    Route::get('/search/{search}', function ($search) {
        return $search;
    })->where('search', '.*');

> {note} Закодированные обратные слеши поддерживаются только в рамках последнего сегмента маршрута.

<a name="named-routes"></a>
## Именованные маршруты

Именованные маршруты позволяют удобно создавать URL-адреса или перенаправления для определенных маршрутов. Вы можете указать имя для маршрута, связав метод `name` с определением маршрута:

    Route::get('/user/profile', function () {
        //
    })->name('profile');

Вы также можете указать имена маршрутов для действий контроллера:

    Route::get(
        '/user/profile',
        [UserProfileController::class, 'show']
    )->name('profile');

> {note} Имена маршрутов всегда должны быть уникальными.

<a name="generating-urls-to-named-routes"></a>
#### Создание URL-адресов для именованных маршрутов

После того, как вы присвоили имя указанному маршруту, вы можете использовать имя маршрута при генерации URL-адресов или перенаправлений с помощью вспомогательных функций `route` и `redirect` Laravel:

    // Создание URL-адреса ...
    $url = route('profile');

    // Создание перенаправления ...
    return redirect()->route('profile');

Если именованный маршрут определяет параметры, вы можете передать параметры в качестве второго аргумента функции `route`. Указанные параметры будут автоматически вставлены в сгенерированный URL в соответствующие места:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1]);

Если вы передадите дополнительные параметры в массиве, то эти пары ключ / значение будут автоматически добавлены в строку запроса сгенерированного URL-адреса:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);

    // /user/1/profile?photos=yes

> {tip} Иногда вам может потребоваться для всего запроса указать значение по умолчанию для параметров URL, например, текущую язык. Для этого вы можете использовать метод [`URL::defaults` method](urls.md#default-values).

<a name="inspecting-the-current-route"></a>
#### Инспектирование текущего маршрута

Если вы хотите определить, был ли текущий запрос направлен на конкретный именованный маршрут, то вы можете использовать метод `named` экземпляра `Route`. Например, вы можете проверить имя текущего маршрута из посредника маршрута:

    /**
     * Обработка входящего запроса.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->route()->named('profile')) {
            //
        }

        return $next($request);
    }

<a name="route-groups"></a>
## Группы маршрутов

Группы маршрутов позволяют совместно использовать атрибуты маршрута, такие как посредники, для большого количества маршрутов без необходимости определять эти атрибуты для каждого маршрута отдельно.

Вложенные группы пытаются разумно «объединить» атрибуты со своей родительской группой. Посредник и условия `where` объединяются, а имена и префиксы добавляются. Разделители пространства имен и слеши в префиксах URI автоматически добавляются там, где это необходимо.

<a name="route-group-middleware"></a>
### Посредники

Чтобы назначить [посредника](middleware.md) всем маршрутам в группе, вы можете использовать метод `middleware` перед определением группы. Посредники будут выполняться в том порядке, в котором они перечислены в массиве:

    Route::middleware(['first', 'second'])->group(function () {
        Route::get('/', function () {
            // Использует посредники `first` и `second` ...
        });

        Route::get('/user/profile', function () {
            // Использует посредники `first` и `second` ...
        });
    });

<a name="route-group-subdomain-routing"></a>
### Маршрутизация поддоменов

Группы маршрутов также могут использоваться для управления маршрутизацией поддоменов. Поддоменам могут быть назначены параметры маршрута так же, как и URI маршрута, что позволяет вам отследить часть поддомена для использования в вашем маршруте или контроллере. Поддомен можно указать, вызвав метод `domain` перед определением группы:

    Route::domain('{account}.example.com')->group(function () {
        Route::get('user/{id}', function ($account, $id) {
            //
        });
    });

> {note} Чтобы обеспечить доступность маршрутов поддоменов, вы должны зарегистрировать маршруты поддоменов перед регистрацией маршрутов корневого домена. Это предотвратит перезапись маршрутами корневого домена маршрутов поддоменов, имеющих одинаковый путь URI.

<a name="route-group-prefixes"></a>
### Префиксы URI сгруппированных маршрутов

Метод `prefix` может использоваться для подстановки префикса каждому маршруту в группе указанным URI. Например, вы можете захотеть подставить перед всеми URI маршрутов в группе префикс `admin`:

    Route::prefix('admin')->group(function () {
        Route::get('/users', function () {
            // Соответствует URL-адресу `/admin/users` ...
        });
    });

<a name="route-group-name-prefixes"></a>
### Префиксы имен сгруппированных маршрутов

Метод `name` может использоваться для подстановки префикса каждого имени маршрута в группе указанной строкой. Например, вы можете захотеть подставить перед всеми именами сгруппированных маршрутов префикс `admin`. Данная строка создаст префикс имени маршрута точно в том виде, в котором он указан, поэтому мы обязательно предоставим завершающий символ `.` в префиксе:

    Route::name('admin.')->group(function () {
        Route::get('/users', function () {
            // Маршруту присвоено имя `admin.users` ...
        })->name('users');
    });

<a name="route-model-binding"></a>
## Привязка модели к маршруту

При внедрении идентификатора модели в маршрут или действие контроллера вы часто будете запрашивать базу данных, чтобы получить модель с соответствующим идентификатором. Привязка модели к маршруту Laravel обеспечивает удобный способ автоматического внедрения экземпляров модели непосредственно в ваши маршруты. Например, вместо того, чтобы внедрять идентификатор пользователя, вы можете внедрить весь экземпляр модели `User` с соответствующим идентификатором.

<a name="implicit-binding"></a>
### Неявная привязка

Laravel автоматически извлечет модели Eloquent, определенные в маршрутах или действиях контроллера, чьи имена переменных объявленного типа соответствуют имени сегмента маршрута. Например:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        return $user->email;
    });

Так как переменная `$user` типизирована как модель `App\Models\User` Eloquent и имя переменной соответствует сегменту URI `{user}`, Laravel автоматически внедрит экземпляр модели с идентификатором, совпадающим со значением URI из запроса. Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован `404` HTTP-ответ.

Конечно, неявная привязка также возможна при использовании методов контроллера. Опять же, обратите внимание, что сегмент `{user}` URI соответствует переменной `$user` в контроллере, которая типизирована как `App\Models\User`:

    use App\Http\Controllers\UserController;
    use App\Models\User;

    // Определение маршрута ...
    Route::get('/users/{user}', [UserController::class, 'show']);

    // Определение метода контроллера ...
    public function show(User $user)
    {
        return view('user.profile', ['user' => $user]);
    }

<a name="customizing-the-key"></a>
<a name="customizing-the-default-key-name"></a>
#### Изменение ключа по умолчанию

По желанию можно извлекать модели Eloquent, используя столбец, отличный от `id`. Для этого вы можете указать столбец в определении параметра маршрута:

    use App\Models\Post;

    Route::get('/posts/{post:slug}', function (Post $post) {
        return $post;
    });

Если вы хотите, чтобы при привязка модели всегда использовался столбец базы данных, отличный от `id`, при извлечении данного класса модели, то вы можете переопределить метод `getRouteKeyName` модели Eloquent:

    /**
     * Получить ключ маршрута для модели.
     *
     * @return string
     */
    public function getRouteKeyName()
    {
        return 'slug';
    }

<a name="implicit-model-binding-scoping"></a>
#### Измененный ключ и ограничения неявной привязки модели

При неявном связывании нескольких моделей Eloquent в одном определении маршрута вы можете захотеть ограничить вторую модель Eloquent так, чтобы она была дочерней по отношению к предыдущей модели Eloquent. Например, рассмотрим это определение маршрута, которое извлекает сообщение в блоге по `slug` для конкретного пользователя:

    use App\Models\Post;
    use App\Models\User;

    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
        return $post;
    });

При использовании неявной привязки с измененным ключом в качестве параметра вложенного маршрута, Laravel автоматически задает ограничение запроса для получения вложенной модели своим родителем, используя соглашения, чтобы угадать имя отношения родительской модели. В этом случае предполагается, что модель `User` имеет отношение с именем `posts` (форма множественного числа имени параметра маршрута), которое можно использовать для получения модели `Post`.

<a name="explicit-binding"></a>
### Явная привязка

Вам не обязательно использовать неявные привязки модели на основе соглашений Laravel, чтобы использовать привязку модели. Вы также можете явно определить, как параметры маршрута должны соответствовать моделям. Чтобы зарегистрировать явную привязку, используйте метод маршрутизатора `model`, чтобы указать класс для переданного параметра. Вы должны определить ваши явные привязки модели в начале метода `boot` вашего класса `RouteServiceProvider`:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определить связывание модели и маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::model('user', User::class);

        // ...
    }

Затем определите маршрут, содержащий параметр `{user}`:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        //
    });

Поскольку мы связали все параметры `{user}` с моделью `App\Models\User`, экземпляр этого класса будет внедрен в маршрут. Так, например, при запросе `users/1` будет внедрен экземпляр `User` из базы данных с идентификатором `1`.

Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован `404` HTTP-ответ.

<a name="customizing-the-resolution-logic"></a>
#### Изменение логики связывания

Если вы хотите определить свою собственную логику связывания модели, вы можете использовать метод `Route::bind`. Замыкание, которое вы передаете методу `bind`, получит значение сегмента URI и должно вернуть экземпляр класса, который должен быть внедрен в маршрут. Опять же, эти изменения должны выполняться в методе `boot` поставщика `RouteServiceProvider` вашего приложения:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определить связывание модели и маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::bind('user', function ($value) {
            return User::where('name', $value)->firstOrFail();
        });

        // ...
    }

В качестве альтернативы вы можете переопределить метод `resolveRouteBinding` в вашей модели Eloquent. Этот метод получит значение сегмента URI и должен вернуть экземпляр класса, который должен быть внедрен в маршрут:

    /**
     * Получить модель для привязанного к маршруту значения.
     *
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveRouteBinding($value, $field = null)
    {
        return $this->where('name', $value)->firstOrFail();
    }

Если в маршруте используется [ограничения неявной привязки модели](#implicit-model-binding-scoping), то будет использоваться метод `resolveChildRouteBinding` родительской модели для получения связанной дочерней модели:

    /**
     * Получить дочернюю модель для привязанного к маршруту значения.
     *
     * @param  string  $childType
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveChildRouteBinding($childType, $value, $field)
    {
        return parent::resolveChildRouteBinding($childType, $value, $field);
    }

<a name="fallback-routes"></a>
## Резервные маршруты

Используя метод `Route::fallback`, вы можете определить маршрут, который будет выполняться, когда ни один другой маршрут не соответствует входящему запросу. Как правило, необработанные запросы автоматически отображают страницу «404» через обработчик исключений вашего приложения. Однако, поскольку вы обычно определяете резервный маршрут в своем файле `routes/web.php`, все посредники группы `web` будет применены к этому маршруту. При необходимости вы можете добавить дополнительн посредников для этого маршрута:

    Route::fallback(function () {
        //
    });

> {note} Резервный маршрут всегда должен быть последним зарегистрированным маршрутом вашего приложения.

<a name="rate-limiting"></a>
## Ограничение количества запросов

<a name="defining-rate-limiters"></a>
### Определение ограничителей количества запросов

Laravel содержит мощные и настраиваемые службы ограничения количества запросов, которые вы можете использовать для ограничения объема трафика для конкретного маршрута или группы маршрутов. Для начала вы должны определить конфигурации ограничителя, которые соответствуют потребностям вашего приложения. Как правило, это должно выполняться в методе `configureRateLimiting` класса `App\Providers\RouteServiceProvider` вашего приложения.

Ограничители определяются с помощью метода `for` фасада `RateLimiter`. Метод `for` принимает имя ограничителя и замыкание, которое возвращает конфигурацию ограничений, применяемых к назначенным маршрутам. Конфигурация ограничений – это экземпляры класса `Illuminate\Cache\RateLimiting\Limit`. Этот класс содержит полезные методы «построения», чтобы вы могли быстро определить свой лимит. Имя ограничителя может быть любой строкой по вашему желанию:

    use Illuminate\Cache\RateLimiting\Limit;
    use Illuminate\Support\Facades\RateLimiter;

    /**
     * Настроить ограничители количества запросов для приложения.
     *
     * @return void
     */
    protected function configureRateLimiting()
    {
        RateLimiter::for('global', function (Request $request) {
            return Limit::perMinute(1000);
        });
    }

Если входящий запрос превышает указанный предел, Laravel автоматически вернет ответ с 429 кодом состояния HTTP. Если вы хотите определить свой собственный ответ, который должен возвращаться, то вы можете использовать метод `response`:

    RateLimiter::for('global', function (Request $request) {
        return Limit::perMinute(1000)->response(function () {
            return response('Custom response...', 429);
        });
    });

Поскольку замыкание получает экземпляр входящего HTTP-запроса, вы можете динамически создать ограничение на основе входящего запроса или статуса аутентификации пользователя:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100);
    });

<a name="segmenting-rate-limits"></a>
#### Сегментирование ограничений количества запросов

Иногда может потребоваться сегментировать лимиты по некоторым произвольным значениям. Например, вы можете разрешить пользователям получать доступ к заданному маршруту 100 раз в минуту на каждый IP-адрес. Для этого можно использовать метод `by` при построении лимита:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100)->by($request->ip());
    });

<a name="multiple-rate-limits"></a>
#### Множественные ограничения количества запросов

При необходимости вы можете вернуть массив ограничений для переданной конфигурации ограничителя. Каждое ограничение будет оцениваться для маршрута в зависимости от порядка, в котором они размещены в массиве:

    RateLimiter::for('login', function (Request $request) {
        return [
            Limit::perMinute(500),
            Limit::perMinute(3)->by($request->input('email')),
        ];
    });

<a name="attaching-rate-limiters-to-routes"></a>
### Привязка ограничителей количества запросов к маршрутам

Ограничители могут быть закреплены за маршрутами или группами маршрутов с помощью [посредника](middleware.md) `throttle`. Посредник `throttle` принимает имя ограничителя, которое вы хотите назначить маршруту:

    Route::middleware(['throttle:uploads'])->group(function () {
        Route::post('/audio', function () {
            //
        });

        Route::post('/video', function () {
            //
        });
    });

<a name="throttling-with-redis"></a>
#### Использование Redis для посредника `throttle`

Как правило, посредник `throttle` сопоставлен классу `Illuminate\Routing\Middleware\ThrottleRequests`. Это сопоставление определено в HTTP-ядре вашего приложения (`App\Http\Kernel`). Однако, если вы используете Redis в качестве драйвера кеша вашего приложения, вы можете изменить это сопоставление, чтобы использовать класс `Illuminate\Routing\Middleware\ThrottleRequestsWithRedis`. Этот класс более эффективен при управлении ограничениями запросов с помощью Redis:

    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class,

<a name="form-method-spoofing"></a>
## Подмена методов формы

HTML-формы не поддерживают действия `PUT`, `PATCH` или `DELETE`. Таким образом, при определении маршрутов `PUT`, `PATCH` или `DELETE`, которые вызываются из HTML-формы, вам нужно будет добавить в форму скрытое поле `_method`. Значение, отправленное с полем `_method`, будет использоваться как метод HTTP-запроса:

    <form action="/example" method="POST">
        <input type="hidden" name="_method" value="PUT">
        <input type="hidden" name="_token" value="{{ csrf_token() }}">
    </form>

Для удобства вы можете использовать директиву `@method` [шаблонизатора Blade](blade.md) для создания поля ввода `_method`:

    <form action="/example" method="POST">
        @method('PUT')
        @csrf
    </form>

<a name="accessing-the-current-route"></a>
## Доступ к текущему маршруту

Вы можете использовать методы `current`, `currentRouteName` и `currentRouteAction` фасада `Route` для доступа к информации о маршруте, обрабатывающем входящий запрос:

    use Illuminate\Support\Facades\Route;

    $route = Route::current(); // Illuminate\Routing\Route
    $name = Route::currentRouteName(); // string
    $action = Route::currentRouteAction(); // string

Вы можете обратиться к документации API [базового класса фасада Route](https://laravel.com/api/8.x/Illuminate/Routing/Router.html) и [экземпляра Route](https://laravel.com/api/8.x/Illuminate/Routing/Route.html), чтобы просмотреть все методы, доступные в классах маршрутизатора и маршрута.

<a name="cors"></a>
## Совместное использование ресурсов между источниками (CORS)

Laravel может автоматически отвечать на HTTP-запросы CORS `OPTIONS` значениями, которые вы сконфигурируете. Все параметры CORS могут быть настроены в файле конфигурации вашего приложения `config/cors.php`. Запросы `OPTIONS` будут автоматически обрабатываться [посредником](middleware.md) `HandleCors`, который по умолчанию входит в ваш глобальный стек посредников. Ваш глобальный стек посредников находится в HTTP-ядре вашего приложения (`App\Http\Kernel`).

> {tip} Для получения дополнительной информации о CORS и заголовках CORS обратитесь к [веб-документации MDN по CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers).

<a name="route-caching"></a>
## Кэширование маршрутов

При развертывании вашего приложения на рабочем веб-ервере, вы должны воспользоваться кешем маршрутов Laravel. Использование кеша маршрутов резко сократит время, необходимое для регистрации всех маршрутов вашего приложения. Чтобы сгенерировать кеш маршрута, выполните команду `route:cache` Artisan:

    php artisan route:cache

После выполнения этой команды ваш кешированный файл маршрутов будет загружаться при каждом запросе. Помните, что если вы добавляете какие-либо новые маршруты, вам нужно будет сгенерировать новый кеш маршрутов. По этой причине вы должны запускать команду `route:cache` только во время развертывания вашего проекта.

Вы можете использовать команду `route:clear` для очистки кеша маршрута:

    php artisan route:clear
