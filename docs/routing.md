# Laravel 9 · Маршрутизация

- [Основы маршрутизации](#basic-routing)
    - [Маршруты перенаправлений](#redirect-routes)
    - [Маршруты представлений](#view-routes)
    - [Список маршрутов](#the-route-list)
- [Параметры маршрута](#route-parameters)
    - [Обязательные параметры](#required-parameters)
    - [Необязательные параметры](#parameters-optional-parameters)
    - [Ограничения регулярного выражения](#parameters-regular-expression-constraints)
- [Именованные маршруты](#named-routes)
- [Группы маршрутов](#route-groups)
    - [Посредники](#route-group-middleware)
    - [Контроллеры](#route-group-controllers)
    - [Маршрутизация поддоменов](#route-group-subdomain-routing)
    - [Префиксы URI сгруппированных маршрутов](#route-group-prefixes)
    - [Префиксы имен сгруппированных маршрутов](#route-group-name-prefixes)
- [Привязка модели к маршруту](#route-model-binding)
    - [Неявная привязка](#implicit-binding)
    - [Неявная привязка с типизированными перечислениями](#implicit-enum-binding)
    - [Явная привязка](#explicit-binding)
- [Резервные маршруты](#fallback-routes)
- [Ограничение частоты запросов](#rate-limiting)
    - [Определение ограничителей частоты запросов](#defining-rate-limiters)
    - [Привязка ограничителей частоты запросов к маршрутам](#attaching-rate-limiters-to-routes)
- [Подмена методов формы](#form-method-spoofing)
- [Доступ к текущему маршруту](#accessing-the-current-route)
- [Совместное использование ресурсов между источниками (CORS)](#cors)
- [Кеширование маршрутов](#route-caching)

<a name="basic-routing"></a>
## Основы маршрутизации

Простейшие маршруты Laravel принимают URI и замыкание, обеспечивая нетрудоемкий и выразительный метод определения маршрутов и поведения без сложных конфигурационных файлов маршрутизации:

    use Illuminate\Support\Facades\Route;

    Route::get('/greeting', function () {
        return 'Hello World';
    });

<a name="the-default-route-files"></a>
#### Файлы маршрутов по умолчанию

Все маршруты Laravel должны быть определены в файлах маршрутов, находящихся в вашем каталоге `routes`. Эти файлы автоматически загружаются вашим поставщиком `App\Providers\RouteServiceProvider` приложения. Файл `routes/web.php` определяет маршруты для вашего веб-интерфейса. Этим маршрутам назначается группа посредников `web`, которая обеспечивает такие функции, как состояние сессии и защита от CSRF. Маршруты в `routes/api.php` не сохраняют состояния и им назначается группа посредников `api`.

Для большинства приложений вы начнете с определения маршрутов в файле `routes/web.php`. К маршрутам, определенным в `routes/web.php`, можно получить доступ, введя URL-адрес определенного маршрута в вашем браузере. Например, вы можете получить доступ к следующему маршруту, перейдя по адресу `http://example.com/user` в своем браузере:

    use App\Http\Controllers\UserController;

    Route::get('/user', [UserController::class, 'index']);

Маршруты, определенные в файле `routes/api.php`, вложены в группу маршрутов в `RouteServiceProvider`. Внутри этой группы автоматически применяется префикс URI `/api`, поэтому вам не нужно вручную добавлять его к каждому маршруту в файле маршрутов. Вы можете изменить префикс и другие параметры группы маршрутов, изменив свой класс `RouteServiceProvider`.

<a name="available-router-methods"></a>
#### Доступные методы маршрутизатора

Маршрутизатор позволяет регистрировать маршруты, отвечающие на любой HTTP-метод:

    Route::get($uri, $callback);
    Route::post($uri, $callback);
    Route::put($uri, $callback);
    Route::patch($uri, $callback);
    Route::delete($uri, $callback);
    Route::options($uri, $callback);

Иногда требуется зарегистрировать маршрут, отвечающий на несколько HTTP-методов. Вы можете сделать это с помощью метода `match`. Или вы даже можете зарегистрировать маршрут, отвечающий на все HTTP-методы, используя метод `any`:

    Route::match(['get', 'post'], '/', function () {
        //
    });

    Route::any('/', function () {
        //
    });

> {tip} При определении нескольких маршрутов с одним и тем же URI, маршруты с использованием методов `get`, `post`, `put`, `patch`, `delete` и `options` должны быть определены перед маршрутами с использованием методов `any`, `match` и `redirect`. Это гарантирует, что входящий запрос будет корректно сопоставлен маршруту.

<a name="dependency-injection"></a>
#### Внедрение зависимости

Вы можете объявить любые зависимости, необходимые для вашего маршрута, в сигнатуре замыкания вашего маршрута. Объявленные зависимости будут автоматически извлечены и внедрены в замыкание с помощью [контейнера служб](container.md) Laravel. Например, вы можете объявить класс `Illuminate\Http\Request`, чтобы текущий HTTP-запрос автоматически был внедрен в замыкание вашего маршрута:

    use Illuminate\Http\Request;

    Route::get('/users', function (Request $request) {
        // ...
    });

<a name="csrf-protection"></a>
#### Защита от CSRF

Помните, что любые HTML-формы, указывающие на маршруты `POST`, `PUT`, `PATCH` или `DELETE`, которые определены в файле маршрутов `web`, должны включать поле токена CSRF. В противном случае запрос будет отклонен. Вы можете прочитать больше о защите от CSRF в [документации CSRF](csrf.md):

    <form method="POST" action="/profile">
        @csrf
        ...
    </form>

<a name="redirect-routes"></a>
### Маршруты перенаправлений

Если вы определяете маршрут, который перенаправляет на другой URI, то вы можете использовать метод `Route::redirect`. Этот метод имеет лаконичную запись, так что вам не нужно определять полный маршрут или контроллер для выполнения простого перенаправления:

    Route::redirect('/here', '/there');

По умолчанию `Route::redirect` возвращает код состояния `302`. Вы можете переопределить код состояния, используя необязательный третий параметр:

    Route::redirect('/here', '/there', 301);

Или вы можете использовать метод `Route::permanentRedirect` для возврата кода состояния `301`:

    Route::permanentRedirect('/here', '/there');

> {note} При использовании параметров маршрута в маршрутах перенаправления, следующие параметры зарезервированы Laravel и не могут быть использованы: `destination` и `status`.

<a name="view-routes"></a>
### Маршруты представлений

Если ваш маршрут должен возвращать только [HTML-шаблон](views.md), то вы можете использовать метод `Route::view`. Как и метод `redirect`, этот метод имеет лаконичную запись, так что вам не нужно полностью определять маршрут или контроллер. Метод `view` принимает URI в качестве первого аргумента и имя шаблона в качестве второго аргумента. Кроме того, вы можете указать массив данных для передачи в шаблон в качестве необязательного третьего аргумента:

    Route::view('/welcome', 'welcome');

    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

> {note} При использовании параметров маршрута в маршрутах представлений, следующие параметры зарезервированы Laravel и не могут быть использованы: `view`, `data`, `status` и `headers`.

<a name="the-route-list"></a>
### Список маршрутов

Команда `route:list` Artisan может легко предоставить обзор всех маршрутов, определенных вашим приложением:

```shell
php artisan route:list
```

По умолчанию посредник, назначенный каждому маршруту, не будет отображаться при выводе `route:list`; однако вы можете указать Laravel отображать посредников маршрута, добавив в команду параметр `-v`:

```shell
php artisan route:list -v
```

Кроме того, вы можете указать Laravel скрывать любые маршруты, определенные сторонними пакетами, указав параметр `--except-vendor` при выполнении команды `route:list`:

```shell
php artisan route:list --except-vendor
```

Так же вы можете указать Laravel показывать только те маршруты, которые определены сторонними пакетами, указав параметр `--only-vendor` при выполнении команды `route:list`:

```shell
php artisan route:list --only-vendor
```

<a name="route-parameters"></a>
## Параметры маршрута

<a name="required-parameters"></a>
### Обязательные параметры

Иногда бывает необходимым отслеживание сегментов URI в вашем маршруте. Например, вам может потребоваться отследить идентификатор пользователя из URL-адреса. Вы можете сделать это, указав параметры маршрута:

    Route::get('/user/{id}', function ($id) {
        return 'User '.$id;
    });

Вы можете определить столько параметров маршрута, сколько потребуется для вашего маршрута:

    Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {
        //
    });

Параметры маршрута всегда заключаются в фигурные скобки `{}` и должны состоять из буквенных символов. Подчеркивание (`_`) также допускается в именах параметров маршрута. Параметры маршрута будут внедрены в замыкания маршрута / контроллеры в зависимости от их порядка, т.е. имена аргументов замыкания маршрута / контроллера не имеют значения.

<a name="parameters-and-dependency-injection"></a>
#### Параметры и внедрение зависимости

Если у вашего маршрута есть зависимости, которые вы хотите, чтобы контейнер служб Laravel автоматически внедрил в замыкание вашего маршрута, то вы должны указать эти зависимости **перед** параметрами маршрута:

    use Illuminate\Http\Request;

    Route::get('/user/{id}', function (Request $request, $id) {
        return 'User '.$id;
    });

<a name="parameters-optional-parameters"></a>
### Необязательные параметры

Иногда требуется указать параметр маршрута, который не всегда может присутствовать в URI. Вы можете сделать это, поставив знак `?` после имени параметра. Не забудьте присвоить соответствующей переменной маршрута значение по умолчанию:

    Route::get('/user/{name?}', function ($name = null) {
        return $name;
    });

    Route::get('/user/{name?}', function ($name = 'John') {
        return $name;
    });

<a name="parameters-regular-expression-constraints"></a>
### Ограничения регулярного выражения

Вы можете ограничить формат параметров вашего маршрута, используя метод `where` экземпляра маршрута. Метод `where` принимает имя параметра и регулярное выражение, определяющее, как параметр должен быть ограничен:

    Route::get('/user/{name}', function ($name) {
        //
    })->where('name', '[A-Za-z]+');

    Route::get('/user/{id}', function ($id) {
        //
    })->where('id', '[0-9]+');

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Для некоторых часто используемых шаблонов регулярных выражений есть соответствующие вспомогательные методы, позволяющие быстро добавлять их к вашим маршрутам:

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->whereNumber('id')->whereAlpha('name');

    Route::get('/user/{name}', function ($name) {
        //
    })->whereAlphaNumeric('name');

    Route::get('/user/{id}', function ($id) {
        //
    })->whereUuid('id');

    Route::get('/category/{category}', function ($category) {
        //
    })->whereIn('category', ['movie', 'song', 'painting']);

Если входящий запрос не соответствует ограничениям шаблона маршрута, то будет возвращен `404` HTTP-ответ.

<a name="parameters-global-constraints"></a>
#### Глобальные ограничения

Если вы хотите, чтобы параметр маршрута всегда ограничивался конкретным регулярным выражением, то вы можете использовать метод `pattern`. Вы должны определить эти шаблоны в методе `boot` поставщика `App\Providers\RouteServiceProvider`:

    /**
     * Определить связывание модели и маршрута, шаблоны ограничений регулярных выражений и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

Как только шаблон определен, он автоматически применяется ко всем маршрутам, использующим это имя параметра:

    Route::get('/user/{id}', function ($id) {
        // Выполнится, только если параметр `{id}` имеет числовое значение ...
    });

<a name="parameters-encoded-forward-slashes"></a>
#### Кодирование обратных слешей

Компонент маршрутизации Laravel позволяет всем символам, кроме обратного слеша (`/`), присутствовать в значениях параметров маршрута. Вы должны явно разрешить `/` быть частью заполнителя `{}`, используя регулярное выражение условия `where`:

    Route::get('/search/{search}', function ($search) {
        return $search;
    })->where('search', '.*');

> {note} Обратные слеши поддерживаются только в рамках последнего сегмента маршрута.

<a name="named-routes"></a>
## Именованные маршруты

Именованные маршруты позволяют легко создавать URL-адреса или перенаправления для определенных маршрутов. Вы можете указать имя для маршрута, связав метод `name` с определением маршрута:

    Route::get('/user/profile', function () {
        //
    })->name('profile');

Вы также можете указать имена маршрутов для действий контроллера:

    Route::get(
        '/user/profile',
        [UserProfileController::class, 'show']
    )->name('profile');

> {note} Имена маршрутов всегда должны быть уникальными.

<a name="generating-urls-to-named-routes"></a>
#### Создание URL-адресов для именованных маршрутов

После того, как вы присвоили имя указанному маршруту, вы можете использовать имя маршрута при генерации URL-адресов или перенаправлений с помощью вспомогательных глобальных функций `route` и `redirect` Laravel:

    // Создание URL-адреса ...
    $url = route('profile');

    // Создание перенаправления ...
    return redirect()->route('profile');

Если именованный маршрут определяет параметры, то вы можете передать параметры в качестве второго аргумента функции `route`. Указанные параметры будут автоматически подставлены в сгенерированный URL в соответствующие места:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1]);

Если вы передадите дополнительные параметры в массиве, то эти пары ключ / значение будут автоматически добавлены в строку запроса сгенерированного URL-адреса:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);

    // /user/1/profile?photos=yes

> {tip} Иногда требуется указать значение по умолчанию для параметров URL запроса, например, текущий язык. Для этого вы можете использовать метод [`URL::defaults`](urls.md#default-values).

<a name="inspecting-the-current-route"></a>
#### Получение информации о текущем именованном маршруте

Если вы хотите определить, был ли текущий запрос направлен на конкретный именованный маршрут, то вы можете использовать метод `named` экземпляра `Route`. Например, вы можете проверить имя текущего маршрута из посредника маршрута:

    /**
     * Обработка входящего запроса.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->route()->named('profile')) {
            //
        }

        return $next($request);
    }

<a name="route-groups"></a>
## Группы маршрутов

Группы маршрутов позволяют совместно использовать атрибуты маршрута (например, посредники) для большого количества маршрутов без необходимости определять эти атрибуты для каждого маршрута отдельно.

Вложенные группы пытаются разумно «объединить» атрибуты со своей родительской группой. Посредники и условия `where` объединяются, а имена и префиксы добавляются. Разделители пространства имен и слеши в префиксах URI автоматически добавляются там, где это необходимо.

<a name="route-group-middleware"></a>
### Посредники

Чтобы назначить [посредника](middleware.md) всем маршрутам в группе, вы можете использовать метод `middleware` перед определением группы. Посредники будут выполняться в том порядке, в котором они перечислены в массиве:

    Route::middleware(['first', 'second'])->group(function () {
        Route::get('/', function () {
            // Использует посредники `first` и `second` ...
        });

        Route::get('/user/profile', function () {
            // Использует посредники `first` и `second` ...
        });
    });

<a name="route-group-controllers"></a>
### Контроллеры

Если группа маршрутов использует один и тот же [контроллер](controllers.md), то вы можете использовать метод `controller`, чтобы определить общий контроллер для всех маршрутов в группе. Затем при определении маршрутов вам нужно только указать метод контроллера, который они вызывают:

    use App\Http\Controllers\OrderController;

    Route::controller(OrderController::class)->group(function () {
        Route::get('/orders/{id}', 'show');
        Route::post('/orders', 'store');
    });

<a name="route-group-subdomain-routing"></a>
### Маршрутизация поддоменов

Группы маршрутов также могут использоваться для управления маршрутизацией поддоменов. Поддоменам могут быть назначены параметры маршрута так же, как и URI маршрута, что позволяет вам отследить сегмент с поддоменом для использования его в вашем маршруте или контроллере. Поддомен можно указать, вызвав метод `domain` перед определением группы:

    Route::domain('{account}.example.com')->group(function () {
        Route::get('user/{id}', function ($account, $id) {
            //
        });
    });

> {note} Чтобы обеспечить доступность маршрутов поддоменов, вы должны зарегистрировать маршруты поддоменов перед регистрацией маршрутов корневого домена. Это предотвратит перезапись маршрутами корневого домена маршрутов поддоменов, имеющих одинаковый путь URI.

<a name="route-group-prefixes"></a>
### Префиксы URI сгруппированных маршрутов

Метод `prefix` используется для подстановки указанного URI в качестве префикса каждому маршруту в группе. Например, можно подставить префикс `admin` перед всеми URI сгруппированных маршрутов:

    Route::prefix('admin')->group(function () {
        Route::get('/users', function () {
            // Соответствует URL-адресу `/admin/users` ...
        });
    });

<a name="route-group-name-prefixes"></a>
### Префиксы имен сгруппированных маршрутов

Метод `name` используется для подстановки указанной строки в качестве префикса имени каждому маршруту в группе. Например, можно подставить префикс `admin` перед всеми именами сгруппированных маршрутов. Данная строка создаст префикс имени маршрута точно в том виде, в котором он указан, поэтому мы обязательно укажем завершающий символ `.` в префиксе:

    Route::name('admin.')->group(function () {
        Route::get('/users', function () {
            // Маршруту присвоено имя `admin.users` ...
        })->name('users');
    });

<a name="route-model-binding"></a>
## Привязка модели к маршруту

При внедрении идентификатора модели в маршрут или действие контроллера вы часто будете запрашивать базу данных, чтобы получить модель с соответствующим идентификатором. Привязка модели к маршруту Laravel обеспечивает удобный способ автоматического внедрения экземпляров модели непосредственно в ваши маршруты. Например, вместо того, чтобы внедрять идентификатор пользователя, вы можете внедрить весь экземпляр модели `User` с соответствующим идентификатором.

<a name="implicit-binding"></a>
### Неявная привязка

Laravel автоматически извлечет модели Eloquent, определенные в маршрутах или действиях контроллера, чьи имена переменных объявленного типа соответствуют имени сегмента маршрута. Например:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        return $user->email;
    });

Так как переменная `$user` типизирована как модель `App\Models\User` Eloquent и имя переменной соответствует сегменту `{user}` URI, то Laravel автоматически внедрит экземпляр модели с идентификатором, совпадающим со значением URI из запроса. Если соответствующий экземпляр модели не найден в базе данных, то автоматически будет сгенерирован `404` HTTP-ответ.

Конечно, неявная привязка также возможна при использовании методов контроллера. Опять же, обратите внимание, что сегмент `{user}` URI соответствует переменной `$user` в контроллере, которая типизирована как `App\Models\User`:

    use App\Http\Controllers\UserController;
    use App\Models\User;

    // Определение маршрута ...
    Route::get('/users/{user}', [UserController::class, 'show']);

    // Определение метода контроллера ...
    public function show(User $user)
    {
        return view('user.profile', ['user' => $user]);
    }

<a name="implicit-soft-deleted-models"></a>
#### Программно удаленные модели

Как правило, при неявной привязки моделей в результирующем наборе не будут получены [программно удаленные](eloquent.md#soft-deleting) модели. Однако вы можете указать, что бы такие модели были получены при неявной привязке, связав метод `withTrashed` с определением вашего маршрута:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        return $user->email;
    })->withTrashed();

<a name="customizing-the-key"></a>
<a name="customizing-the-default-key-name"></a>
#### Изменение ключа по умолчанию

По желанию можно извлекать модели Eloquent, используя столбец, отличный от `id`. Для этого вы можете указать столбец в определении параметра маршрута:

    use App\Models\Post;

    Route::get('/posts/{post:slug}', function (Post $post) {
        return $post;
    });

Если вы хотите, чтобы при извлечении класса связанной модели всегда использовался столбец базы данных, отличный от `id`, то вы можете переопределить метод `getRouteKeyName` модели Eloquent:

    /**
     * Получить ключ маршрута для модели.
     *
     * @return string
     */
    public function getRouteKeyName()
    {
        return 'slug';
    }

<a name="implicit-model-binding-scoping"></a>
#### Измененный ключ и ограничения неявной привязки модели

При неявном связывании нескольких моделей Eloquent в одном определении маршрута бывает необходимо ограничить вторую модель Eloquent так, чтобы она была дочерней по отношению к предыдущей модели Eloquent. Например, рассмотрим это определение маршрута, которое извлекает пост в блоге по `slug` для конкретного пользователя:

    use App\Models\Post;
    use App\Models\User;

    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
        return $post;
    });

При использовании неявной привязки с измененным ключом в качестве параметра вложенного маршрута, Laravel автоматически задает ограничение запроса для получения вложенной модели своим родителем, используя соглашения, чтобы угадать имя отношения родительской модели. В этом случае предполагается, что модель `User` имеет отношение с именем `posts` (форма множественного числа имени параметра маршрута), которое можно использовать для получения модели `Post`.

По желанию можно указать Laravel ограничить «дочерние» привязки, даже если ключ не был предоставлен. Для этого вы можете вызвать метод `scopeBindings` при определении вашего маршрута:

    use App\Models\Post;
    use App\Models\User;

    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
        return $post;
    })->scopeBindings();

Или вы можете указать в определении группы маршрутов использовать ограничения привязки:

    Route::scopeBindings()->group(function () {
        Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
            return $post;
        });
    });

<a name="customizing-missing-model-behavior"></a>
#### Настройка поведения при отсутствии модели

Обычно, если неявно связанная модель не найдена, то генерируется `404` HTTP-ответ. Однако вы можете изменить это поведение, вызвав метод `missing` при определении вашего маршрута. Метод `missing` принимает замыкание, которое будет вызываться, если неявно связанная модель не может быть найдена:

    use App\Http\Controllers\LocationsController;
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Redirect;

    Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])
            ->name('locations.view')
            ->missing(function (Request $request) {
                return Redirect::route('locations.index');
            });

<a name="implicit-enum-binding"></a>
### Неявная привязка с типизированными перечислениями

В PHP 8.1 появилась поддержка [типизированных перечислений](https://www.php.net/manual/ru/language.enumerations.backed.php). Laravel позволяет вам указывать типизированным перечислением в определении вашего маршрута, и Laravel будет вызывать маршрут только в том случае, если этот сегмент маршрута соответствует допустимому значению перечисления. В противном случае будет автоматически возвращен 404-ый ответ HTTP. Например, учитывая следующее определение перечисления:

```php
<?php

namespace App\Enums;

enum Category: string
{
    case Fruits = 'fruits';
    case People = 'people';
}
```

Вы можете определить маршрут, который будет вызываться только в том случае, если сегмент маршрута `{category}` имеет значение `fruits` или `people`. В противном случае Laravel вернет 404-ый ответ HTTP:

```php
use App\Enums\Category;
use Illuminate\Support\Facades\Route;

Route::get('/categories/{category}', function (Category $category) {
    return $category->value;
});
```

<a name="explicit-binding"></a>
### Явная привязка

Вам не обязательно использовать неявные привязки модели на основе соглашений Laravel, чтобы использовать привязку модели. Вы также можете явно определить, как параметры маршрута должны быть сопоставлены моделям. Чтобы зарегистрировать явную привязку, используйте метод маршрутизатора `model`, чтобы указать класс для переданного параметра. Вы должны определить ваши явные привязки модели в начале метода `boot` поставщика `App\Providers\RouteServiceProvider`:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определить связывание модели и маршрута, шаблоны ограничений регулярных выражений и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::model('user', User::class);

        // ...
    }

Затем определите маршрут, содержащий параметр `{user}`:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        //
    });

Поскольку мы связали все параметры `{user}` с моделью `App\Models\User`, экземпляр этого класса будет внедрен в маршрут. Так, например, при запросе `users/1` будет внедрен экземпляр `User` из базы данных с идентификатором `1`.

Если соответствующий экземпляр модели не найден в базе данных, то автоматически будет сгенерирован `404` HTTP-ответ.

<a name="customizing-the-resolution-logic"></a>
#### Изменение логики связывания

Если вы хотите определить свою собственную логику связывания модели, то вы можете использовать метод `Route::bind`. Замыкание, которое вы передаете методу `bind`, получит значение сегмента URI и должно вернуть экземпляр класса, который должен быть внедрен в маршрут. Опять же, эти изменения должны выполняться в методе `boot` поставщика `App\Providers\RouteServiceProvider`:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определить связывание модели и маршрута, шаблоны ограничений регулярных выражений и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::bind('user', function ($value) {
            return User::where('name', $value)->firstOrFail();
        });

        // ...
    }

В качестве альтернативы вы можете переопределить метод `resolveRouteBinding` вашей модели Eloquent. Этот метод получит значение сегмента URI и должен вернуть экземпляр класса, который должен быть внедрен в маршрут:

    /**
     * Получить модель для привязанного к маршруту значения параметра.
     *
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveRouteBinding($value, $field = null)
    {
        return $this->where('name', $value)->firstOrFail();
    }

Если в маршруте используется [ограничения неявной привязки модели](#implicit-model-binding-scoping), то для получения связанной дочерней модели будет использоваться метод `resolveChildRouteBinding` родительской модели:

    /**
     * Получить дочернюю модель для привязанного к маршруту значения параметра.
     *
     * @param  string  $childType
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveChildRouteBinding($childType, $value, $field)
    {
        return parent::resolveChildRouteBinding($childType, $value, $field);
    }

<a name="fallback-routes"></a>
## Резервные маршруты

Используя метод `Route::fallback`, вы можете определить маршрут, который будет выполняться, когда ни один другой маршрут не соответствует входящему запросу. Как правило, необработанные запросы автоматически отображают страницу `404` через обработчик исключений вашего приложения. Однако, поскольку вы обычно определяете резервный маршрут в своем файле `routes/web.php`, то все посредники группы `web` будет применены к этому маршруту. При необходимости вы можете добавить дополнительный посредник для этого маршрута:

    Route::fallback(function () {
        //
    });

> {note} Резервный маршрут всегда должен быть последним зарегистрированным маршрутом в вашем приложении.

<a name="rate-limiting"></a>
## Ограничение частоты запросов

<a name="defining-rate-limiters"></a>
### Определение ограничителей частоты запросов

Laravel содержит мощные и настраиваемые службы ограничения частоты запросов, которые вы можете использовать для ограничения объема трафика для конкретного маршрута или группы маршрутов. Для начала вы должны определить конфигурации ограничителя, которые соответствуют потребностям вашего приложения. Как правило, это должно выполняться в методе `configureRateLimiting` поставщика `App\Providers\RouteServiceProvider` вашего приложения.

Ограничители определяются с помощью метода `for` фасада `RateLimiter`. Метод `for` принимает имя ограничителя и замыкание, которое возвращает конфигурацию ограничений, применяемых к назначенным маршрутам. Конфигурация ограничений – это экземпляры класса `Illuminate\Cache\RateLimiting\Limit`. Этот класс содержит полезные методы «построения», чтобы вы могли быстро определить свой «лимит». Имя ограничителя может быть любой строкой по вашему желанию:

    use Illuminate\Cache\RateLimiting\Limit;
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\RateLimiter;

    /**
     * Настроить ограничители частоты запросов для приложения.
     *
     * @return void
     */
    protected function configureRateLimiting()
    {
        RateLimiter::for('global', function (Request $request) {
            return Limit::perMinute(1000);
        });
    }

Если входящий запрос превышает указанный лимит, то Laravel автоматически вернет ответ с `429` кодом состояния HTTP. Если вы хотите определить свой собственный ответ, который должен возвращаться, то вы можете использовать метод `response`:

    RateLimiter::for('global', function (Request $request) {
        return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
            return response('Custom response...', 429, $headers);
        });
    });

Поскольку замыкание получает экземпляр входящего HTTP-запроса, то вы можете динамически создать ограничение на основе входящего запроса или статуса аутентификации пользователя:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100);
    });

<a name="segmenting-rate-limits"></a>
#### Сегментация ограничений частоты запросов

Иногда требуется сегментация ограничений по некоторым произвольным значениям. Например, вы можете разрешить пользователям получать доступ к указанному маршруту 100 раз в минуту на каждый IP-адрес. Для этого можно использовать метод `by` при построении лимита:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100)->by($request->ip());
    });

Чтобы проиллюстрировать этот функционал на другом примере, мы можем ограничить доступ к указанному маршруту до 100 раз в минуту по идентификатору аутентифицированного пользователя или до 10 раз в минуту по IP-адресу для каждого из гостей:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()
                    ? Limit::perMinute(100)->by($request->user()->id)
                    : Limit::perMinute(10)->by($request->ip());
    });

<a name="multiple-rate-limits"></a>
#### Множественные ограничения частоты запросов

При необходимости вы можете вернуть массив ограничений при указании конфигурации ограничителя. Каждое ограничение будет оцениваться для маршрута в зависимости от порядка, в котором они размещены в массиве:

    RateLimiter::for('login', function (Request $request) {
        return [
            Limit::perMinute(500),
            Limit::perMinute(3)->by($request->input('email')),
        ];
    });

<a name="attaching-rate-limiters-to-routes"></a>
### Привязка ограничителей частоты запросов к маршрутам

Ограничители могут быть закреплены за маршрутами или группами маршрутов с помощью [посредника](middleware.md) `throttle`. Посредник `throttle` принимает имя ограничителя, которое вы хотите назначить маршруту:

    Route::middleware(['throttle:uploads'])->group(function () {
        Route::post('/audio', function () {
            //
        });

        Route::post('/video', function () {
            //
        });
    });

<a name="throttling-with-redis"></a>
#### Использование Redis для посредника `throttle`

Как правило, посредник `throttle` сопоставлен классу `Illuminate\Routing\Middleware\ThrottleRequests`. Это сопоставление определено в `App\Http\Kernel` вашего приложения. Если вы используете Redis в качестве драйвера кеша вашего приложения, то вы можете изменить это сопоставление, чтобы использовать класс `Illuminate\Routing\Middleware\ThrottleRequestsWithRedis`. Этот класс более эффективен при управлении ограничениями запросов с помощью Redis:

    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class,

<a name="form-method-spoofing"></a>
## Подмена методов формы

HTML-формы не поддерживают действия `PUT`, `PATCH` или `DELETE`. Таким образом, при определении маршрутов `PUT`, `PATCH` или `DELETE`, которые вызываются из HTML-формы, вам нужно будет добавить в форму скрытое поле `_method`. Значение, отправленное с полем `_method`, будет использоваться как метод HTTP-запроса:

    <form action="/example" method="POST">
        <input type="hidden" name="_method" value="PUT">
        <input type="hidden" name="_token" value="{{ csrf_token() }}">
    </form>

Для удобства вы можете использовать директиву `@method` [шаблонизатора Blade](blade.md) для создания поля ввода `_method`:

    <form action="/example" method="POST">
        @method('PUT')
        @csrf
    </form>

<a name="accessing-the-current-route"></a>
## Доступ к текущему маршруту

Вы можете использовать методы `current`, `currentRouteName` и `currentRouteAction` фасада `Route` для доступа к информации о маршруте, обрабатывающем входящий запрос:

    use Illuminate\Support\Facades\Route;

    $route = Route::current(); // Illuminate\Routing\Route
    $name = Route::currentRouteName(); // string
    $action = Route::currentRouteAction(); // string

Вы можете обратиться к документации API [базового класса фасада Route](https://laravel.com/api/8.x/Illuminate/Routing/Router.html) и [экземпляра Route](https://laravel.com/api/8.x/Illuminate/Routing/Route.html), чтобы просмотреть все методы, доступные в классах маршрутизатора и маршрута.

<a name="cors"></a>
## Совместное использование ресурсов между источниками (CORS)

Laravel может автоматически отвечать на HTTP-запросы CORS `OPTIONS` значениями, которые вы сконфигурируете. Все параметры CORS могут быть настроены в конфигурационном файле `config/cors.php` вашего приложения. Запросы `OPTIONS` будут автоматически обрабатываться [посредником](middleware.md) `HandleCors`, который по умолчанию входит в ваш глобальный стек посредников. Ваш глобальный стек посредников находится в HTTP-ядре вашего приложения (`App\Http\Kernel`).

> {tip} Для получения дополнительной информации о CORS и заголовках CORS обратитесь к [веб-документации MDN по CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers).

<a name="route-caching"></a>
## Кеширование маршрутов

При развертывании вашего приложения на рабочем веб-сервере, вы должны воспользоваться кешем маршрутов Laravel. Использование кеша маршрутов резко сократит время, необходимое для регистрации всех маршрутов вашего приложения. Чтобы сгенерировать кеш маршрута, выполните команду `route:cache` Artisan:

    php artisan route:cache

После выполнения этой команды ваш файл кеша маршрутов будет загружаться при каждом запросе. Помните, что если вы добавляете какие-либо новые маршруты, то вам нужно будет сгенерировать новый кеш маршрутов. По этой причине вы должны запускать команду `route:cache` только во время развертывания вашего проекта.

Вы можете использовать команду `route:clear` для очистки кеша маршрута:

    php artisan route:clear
