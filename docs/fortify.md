# Laravel 9 · Пакет Laravel Fortify

- [Введение](#introduction)
    - [Что такое Fortify?](#what-is-fortify)
    - [Когда я должен использовать Fortify?](#when-should-i-use-fortify)
- [Установка](#installation)
    - [Поставщик службы Fortify](#the-fortify-service-provider)
    - [Функционал Fortify](#fortify-features)
    - [Отключение маршрутов, возвращающих шаблоны](#disabling-views)
- [Аутентификация](#authentication)
    - [Настройка аутентификации пользователя](#customizing-user-authentication)
    - [Настройка конвейера аутентификации](#customizing-the-authentication-pipeline)
    - [Настройка переадресации](#customizing-authentication-redirects)
- [Двухфакторная аутентификация](#two-factor-authentication)
    - [Включение двухфакторной аутентификации](#enabling-two-factor-authentication)
    - [Использование двухфакторной аутентификации](#authenticating-with-two-factor-authentication)
    - [Отключение двухфакторной аутентификации](#disabling-two-factor-authentication)
- [Регистрация](#registration)
    - [Настройка регистрации](#customizing-registration)
- [Сброс пароля](#password-reset)
    - [Запрос ссылки для сброса пароля](#requesting-a-password-reset-link)
    - [Отображение страницы сброса пароля](#resetting-the-password)
    - [Настройка сброса пароля](#customizing-password-resets)
- [Подтверждение адреса электронной почты](#email-verification)
    - [Защита маршрутов](#protecting-routes)
- [Подтверждение пароля](#password-confirmation)

<a name="introduction"></a>
## Введение

[Laravel Fortify](https://github.com/laravel/fortify) – это независимая от внешнего интерфейса серверная реализация аутентификации для Laravel. Fortify регистрирует маршруты и контроллеры, необходимые для реализации всего функционала аутентификации Laravel, включая вход в систему, регистрацию, сброс пароля, подтверждение электронной почты и многое другое. После установки Fortify вы можете запустить команду `route:list` Artisan, чтобы просмотреть маршруты, зарегистрированные Fortify.

Поскольку Fortify не обеспечен собственным пользовательским интерфейсом, он предназначен для работы в паре с вашим собственным пользовательским интерфейсом, который отправляет запросы на регистрируемые им маршруты. Мы обсудим, как именно делать запросы к этим маршрутам, в оставшейся части этой документации.

> {tip} Помните, что Fortify – это пакет, который поможет вам начать реализацию функционала аутентификации Laravel. **Вы не обязаны его использовать.** Вы всегда можете вручную взаимодействовать со службами аутентификации Laravel, следуя документации: [аутентификация](authentication.md), [сброс пароля](passwords.md), и [подтверждение по электронной почте](verification.md).

<a name="what-is-fortify"></a>
### Что такое Fortify?

Как упоминалось ранее, Laravel Fortify – это независимая от внешнего интерфейса серверная реализация аутентификации для Laravel. Fortify регистрирует маршруты и контроллеры, необходимые для реализации всего функционала аутентификации Laravel, включая вход в систему, регистрацию, сброс пароля, подтверждение электронной почты и многое другое.

**Вам не обязательно использовать Fortify, чтобы использовать функционал аутентификации Laravel.** Вы всегда можете вручную взаимодействовать со службами аутентификации Laravel, следуя документации: [аутентификация](authentication.md), [сброс пароля](passwords.md), и [подтверждение по электронной почте](verification.md).

Если вы новичок в Laravel, вы можете изучить стартовый комплект приложения [Laravel Breeze](starter-kits.md), прежде чем пытаться использовать Laravel Fortify. Laravel Breeze предлагает каркас аутентификации для вашего приложения, который включает пользовательский интерфейс, созданный с помощью [Tailwind CSS](https://tailwindcss.com). В отличие от Fortify, Breeze публикует свои маршруты и контроллеры прямо в вашем приложении. Это позволяет вам изучить и освоиться с функционалом аутентификации Laravel, прежде чем позволить Laravel Fortify реализовать этот функционал для вас.

Laravel Fortify по сути берет маршруты и контроллеры Laravel Breeze и предлагает их как пакет, не включающий пользовательский интерфейс. Это позволяет вам по-прежнему быстро строить бэкэнд-реализацию слоя аутентификации вашего приложения, не привязываясь к каким-либо конкретным предпочтениям фронтенда.

<a name="when-should-i-use-fortify"></a>
### Когда я должен использовать Fortify?

Вам может быть интересно, когда уместно использовать Laravel Fortify. Во-первых, если вы используете один из [стартовых комплектов](starter-kits.md) Laravel, вам не нужно устанавливать Laravel Fortify, поскольку все стартовые комплекты приложений Laravel уже обеспечивают полную реализацию аутентификации.

Если вы не используете стартовый комплект приложения и вашему приложению требуются функционал аутентификации, у вас есть два варианта: самостоятельно реализовать функционал аутентификации вашего приложения или использовать Laravel Fortify для обеспечения серверной реализации этого функционала.

Если вы выберете установку Fortify, ваш пользовательский интерфейс будет делать запросы к маршрутам аутентификации Fortify, которые подробно описаны в этой документации, для аутентификации и регистрации пользователей.

Если вы решите самостоятельно взаимодействовать со службами аутентификации Laravel вместо использования Fortify, вы можете сделать это, следуя документации: [аутентификация](authentication.md), [сброс пароля](passwords.md), и [подтверждение по электронной почте](verification.md).

<a name="laravel-fortify-and-laravel-sanctum"></a>
#### Laravel Fortify и Laravel Sanctum

Некоторых разработчиков смущает разница между [Laravel Sanctum](sanctum.md) и Laravel Fortify. Поскольку эти два пакета решают две разные, но связанные проблемы, Laravel Fortify и Laravel Sanctum не являются взаимоисключающими или конкурирующими пакетами.

Laravel Sanctum занимается только управлением токенами API и аутентификацией существующих пользователей с помощью файлов Cookies сессии или токенов. Sanctum не содержит никаких маршрутов для регистрации пользователей, сброса пароля и т. д.

Если вы пытаетесь самостоятельно создать слой аутентификации для приложения, которое предлагает API или служит серверной частью для одностраничного приложения, вполне возможно, что вы будете использовать оба пакета: Laravel Fortify (для регистрации пользователя, сброса пароля и т. д.) и Laravel Sanctum (управление токенами API, аутентификация сессии).

<a name="installation"></a>
## Установка

Для начала установите Fortify с помощью менеджера пакетов Composer в свой проект:

```shell
composer require laravel/fortify
```

Затем, опубликуйте ресурсы Fortify с помощью команды `vendor:publish`:

```shell
php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"
```

Эта команда опубликует действия Fortify в вашем каталоге `app/Actions`, который будет создан, если он не существует. Кроме того, будут опубликованы `FortifyServiceProvider`, файл конфигурации и все необходимые миграции базы данных.

Затем, вы должны применить миграции к вашей базе данных:

```shell
php artisan migrate
```

<a name="the-fortify-service-provider"></a>
### Поставщик службы Fortify

Обсуждаемая выше команда `vendor:publish` также опубликует класс `App\Providers\FortifyServiceProvider`. Вы должны убедиться, что этот класс зарегистрирован в массиве поставщиков файла конфигурации `config/app.php` вашего приложения.

Поставщик службы `FortifyServiceProvider` регистрирует опубликованные действия, и указывает Fortify, использовать их при выполнении соответствующих задач.

<a name="fortify-features"></a>
### Функционал Fortify

Файл конфигурации `fortify` содержит массив конфигурации `features`. Этот массив определяет, какие серверные маршруты / функционал будет предоставлять Fortify по умолчанию. Если вы не используете Fortify в сочетании с [Laravel Jetstream](https://jetstream.laravel.com), то мы рекомендуем вам включить только основной функционал аутентификации, и предоставляемый большинством приложений Laravel:

```php
'features' => [
    Features::registration(),
    Features::resetPasswords(),
    Features::emailVerification(),
],
```

<a name="disabling-views"></a>
### Отключение маршрутов, возвращающих шаблоны

По умолчанию Fortify определяет маршруты, которые предназначены для возврата шаблонов, таких как экран входа в систему или экран регистрации. Однако, если вы создаете одностраничное приложение на основе JavaScript, эти маршруты могут не понадобиться. По этой причине вы можете полностью отключить эти маршруты, установив значение конфигурации `views` в файле конфигурации `config/fortify.php` вашего приложения – `false`:

```php
'views' => false,
```

<a name="disabling-views-and-password-reset"></a>
#### Отключение маршрутов, возвращающих шаблоны и сброс пароля

Если вы решите отключить маршруты Fortify, возвращающие шаблоны и будете реализовывать функционал сброса пароля для своего приложения, то вы все равно должны определить маршрут с именем `password.reset`, который отвечает за отображение шаблона «сброса пароля» вашего приложения. Это необходимо, потому что уведомление Laravel `Illuminate\Auth\Notifications\ResetPassword` генерирует URL для сброса пароля через именованный маршрут `password.reset`.

<a name="authentication"></a>
## Аутентификация

Для начала нам нужно указать Fortify, как вернуть наш шаблон «входа в систему». Помните, что Fortify – это безголовая библиотека аутентификации. Если вам нужна внешняя реализация функционала аутентификации Laravel, которая уже создана для вас, то вам следует использовать [стартовый комплект приложения](starter-kits.md).

Вся логика отрисовки шаблонов аутентификации может быть настроена с использованием соответствующих методов, доступных через класс `Laravel\Fortify\Fortify`. Как правило, вызов соответствующего метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`. Fortify позаботится об определении маршрута `/login`, который возвращает этот шаблон:

    use Laravel\Fortify\Fortify;

    /**
     * Загрузка любых служб приложения.
     *
     * @return void
     */
    public function boot()
    {
        Fortify::loginView(function () {
            return view('auth.login');
        });

        // ...
    }

Ваш шаблон входа в систему должен включать форму, которая отправляет POST-запрос в `/login`. Конечная точка `/login` ожидает строковые поля `email` / `username` и `password`. Имя поля `email` / `username` должно соответствовать значению `username` в конфигурационном файле `config/fortify.php`. Кроме того, может быть предусмотрено логическое поле «Запомнить меня», чтобы указать, что пользователь хотел бы использовать функционал «Запомнить меня», предоставляемый Laravel.

Если попытка входа в систему будет успешной, то Fortify перенаправит вас на URI, настроенный с помощью параметра конфигурации `home` в файле конфигурации `fortify` вашего приложения. Если запрос на вход был запросом XHR, будет возвращен `200` HTTP-ответ.

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану входа в систему, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.

<a name="customizing-user-authentication"></a>
### Настройка аутентификации пользователя

Fortify автоматически извлечет и аутентифицирует пользователя на основе предоставленных учетных данных и охранника аутентификации, настроенного в вашем приложении. Однако иногда требуется полная настройка того, как аутентифицируются учетные данные для входа и извлекаются пользователи. К счастью, Fortify позволяет легко добиться этого с помощью метода `Fortify::authenticateUsing`.

Этот метод принимает замыкание, которое получает входящий HTTP-запрос. Замыкание отвечает за проверку учетных данных для входа, прикрепленных к запросу, и за возврат связанного экземпляра пользователя. Если учетные данные недействительны или пользователь не может быть найден, замыкание должно вернуть `null` или `false`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::authenticateUsing(function (Request $request) {
        $user = User::where('email', $request->email)->first();

        if ($user &&
            Hash::check($request->password, $user->password)) {
            return $user;
        }
    });

    // ...
}
```

<a name="authentication-guard"></a>
#### Охранник аутентификации

Вы можете указать охранника аутентификации, используемую Fortify, в файле конфигурации вашего приложения `fortify`. Однако, вы должны убедиться, что предоставленный охранник является реализацией `Illuminate\Contracts\Auth\StatefulGuard`. Если вы пытаетесь использовать Laravel Fortify для аутентификации SPA, то вам следует использовать стандартного охранника `web` Laravel в сочетании с [Laravel Sanctum](sanctum.md).

<a name="customizing-the-authentication-pipeline"></a>
### Настройка конвейера аутентификации

Laravel Fortify аутентифицирует запросы на вход через конвейер вызываемых классов. При желании вы можете определить собственный конвейер классов, через который должны передаваться запросы на вход. Каждый класс должен иметь метод `__invoke`, который получает экземпляр `Illuminate\Http\Request` входящего запроса и, как [посредник](middleware.md), переменную `$next`, которая упорядоченно вызывается для передачи запроса следующему классу в конвейере.

Чтобы определить свой собственный конвейер, вы можете использовать метод `Fortify::authenticateThrough`. Этот метод принимает замыкание, которое должно возвращать массив классов для передачи запроса входа в систему. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`.

В приведенном ниже примере содержится определение конвейера по умолчанию, которое вы можете использовать в качестве отправной точки при внесении собственных изменений:

```php
use Laravel\Fortify\Actions\AttemptToAuthenticate;
use Laravel\Fortify\Actions\EnsureLoginIsNotThrottled;
use Laravel\Fortify\Actions\PrepareAuthenticatedSession;
use Laravel\Fortify\Actions\RedirectIfTwoFactorAuthenticatable;
use Laravel\Fortify\Fortify;
use Illuminate\Http\Request;

Fortify::authenticateThrough(function (Request $request) {
    return array_filter([
            config('fortify.limiters.login') ? null : EnsureLoginIsNotThrottled::class,
            Features::enabled(Features::twoFactorAuthentication()) ? RedirectIfTwoFactorAuthenticatable::class : null,
            AttemptToAuthenticate::class,
            PrepareAuthenticatedSession::class,
    ]);
});
```

<a name="customizing-authentication-redirects"></a>
### Настройка переадресации

Если попытка входа в систему окажется успешной, то Fortify перенаправит вас на URI, настроенный с помощью параметра `home` конфигурации в конфигурационном файле `fortify` вашего приложения. Если запрос был запросом XHR, будет возвращен `200` HTTP-ответ. После выхода пользователя из приложения он будет перенаправлен на URI `/`.

Если вам нужна расширенная настройка этого поведения, то вы можете связать реализации контрактов `LoginResponse` и `LogoutResponse` в [контейнере служб](container.md) Laravel. Обычно это должно быть сделано в методе `register` поставщика `App\Providers\FortifyServiceProvider` вашего приложения:

```php
use Laravel\Fortify\Contracts\LogoutResponse;

/**
 * Регистрация любых служб приложения.
 *
 * @return void
 */
public function register()
{
    $this->app->instance(LogoutResponse::class, new class implements LogoutResponse {
        public function toResponse($request)
        {
            return redirect('/');
        }
    });
}
```

<a name="two-factor-authentication"></a>
## Двухфакторная аутентификация

Когда функционал двухфакторной аутентификации Fortify включен, тогда пользователь должен ввести шестизначный цифровой токен в процессе аутентификации. Этот токен создается с [использованием одноразового пароля (TOTP)](https://ru.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm), который может быть получен из любого TOTP-совместимого мобильного приложения для аутентификации, например Google Authenticator.

Перед началом работы вы должны убедиться, что модель `App\Models\User` вашего приложения использует трейт `Laravel\Fortify\TwoFactorAuthenticatable`:

```php
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Fortify\TwoFactorAuthenticatable;

class User extends Authenticatable
{
    use Notifiable, TwoFactorAuthenticatable;
}
```

Затем, вы должны создать экран в своем приложении, где пользователи могут управлять своими настройками двухфакторной аутентификации. Этот экран должен позволить пользователю включать и отключать двухфакторную аутентификацию, а также повторно создавать коды восстановления двухфакторной аутентификации.

> {note} По умолчанию массив `features` конфигурационного файла `config/fortify.php` указывает настройкам двухфакторной аутентификации Fortify требовать подтверждения пароля перед изменением. Поэтому, прежде чем продолжить, ваше приложение должно реализовать функционал [подтверждение пароля](#password-confirmation) Fortify.

<a name="enabling-two-factor-authentication"></a>
### Включение двухфакторной аутентификации

Чтобы включить двухфакторную аутентификацию, ваше приложение должно сделать POST-запрос к конечной точке `/user/two-factor-authentication`, определенной Fortify. Если запрос будет успешным, то пользователь будет перенаправлен обратно на предыдущий URL-адрес, а для переменной `status` сессии будет установлено значение `two-factor-authentication-enabled`. Вы можете использовать эту переменную `status` сессии в своих шаблонах, чтобы отобразить соответствующее сообщение об успешном выполнении. Если запрос был запросом XHR, будет возвращен `200` HTTP-ответ.

После выбора включения двухфакторной аутентификации пользователь все равно должен «подтвердить» свою конфигурацию двухфакторной аутентификации, указав действительный код двухфакторной аутентификации. Таким образом, ваше «успешное» сообщение должно указывать пользователю, что по-прежнему требуется подтверждение двухфакторной аутентификации:

```html
@if (session('status') == 'two-factor-authentication-enabled')
    <div class="mb-4 font-medium text-sm">
        Пожалуйста, завершите настройку двухфакторной аутентификации ниже.
    </div>
@endif
```

Затем, вы должны отобразить QR-код двухфакторной аутентификации, чтобы пользователь мог сканировать его своим приложением для аутентификации. Если вы используете Blade для отрисовки интерфейса вашего приложения, то вы можете получить SVG с QR-кодом, используя метод `twoFactorQrCodeSvg` экземпляра пользователя:

```php
$request->user()->twoFactorQrCodeSvg();
```

Если вы создаете интерфейс на основе JavaScript, то вы можете сделать GET-запрос XHR к конечной точке `/user/two-factor-qr-code`, чтобы получить QR-код для двухфакторной аутентификации пользователя. Эта конечная точка вернет объект JSON, содержащий ключ `svg`.

<a name="confirming-two-factor-authentication"></a>
#### Подтверждение двухфакторной аутентификации

В дополнение к отображению QR-кода двухфакторной аутентификации пользователя вы должны отобразить текстовое поле ввод, где пользователь может указать действительный код аутентификации, чтобы «подтвердить» свою конфигурацию двухфакторной аутентификации. Этот код должен быть предоставлен приложению Laravel через POST-запрос к конечной точке `/user/confirmed-two-factor-authentication`, определенной Fortify.

Если запрос выполнен успешно, то пользователь будет перенаправлен обратно на предыдущий URL-адрес, а для переменной `status` сессии будет установлено значение `two-factor-authentication-confirmed`:

```html
@if (session('status') == 'two-factor-authentication-confirmed')
    <div class="mb-4 font-medium text-sm">
        Двухфакторная аутентификация подтверждена и успешно включена.
    </div>
@endif
```

Если запрос к конечной точке подтверждения двухфакторной аутентификации был запросом XHR, будет возвращен `200` HTTP-ответ.

<a name="displaying-the-recovery-codes"></a>
#### Отображение кодов восстановления

Вы также должны отобразить коды двухфакторного восстановления пользователя. Эти коды восстановления позволяют пользователю пройти аутентификацию, если он потеряет доступ к своему мобильному устройству. Если вы используете Blade для отрисовки внешнего интерфейса вашего приложения, то вы можете получить доступ к кодам восстановления через экземпляр аутентифицированного пользователя:

```php
(array) $request->user()->recoveryCodes()
```

Если вы создаете интерфейс на основе JavaScript, то вы можете сделать GET-запрос XHR к конечной точке `/user/two-factor-recovery-codes`. Эта конечная точка вернет массив JSON, содержащий коды восстановления пользователя.

Чтобы повторно сгенерировать коды восстановления пользователя, ваше приложение должно сделать POST-запрос к конечной точке `/user/two-factor-recovery-codes`.

<a name="authenticating-with-two-factor-authentication"></a>
### Использование двухфакторной аутентификации

В процессе аутентификации Fortify автоматически перенаправляет пользователя на экран запроса двухфакторной аутентификации приложения. Однако, если ваше приложение выполняет запрос XHR входа в систему, то ответ JSON, возвращаемый после успешной попытки аутентификации, будет содержать объект JSON, содержащий логическое свойство `two_factor`. Необходимо проверить это значение, чтобы узнать, следует ли перенаправлять на экран запроса двухфакторной аутентификации приложения.

Чтобы начать реализацию функционала двухфакторной аутентификации, нам нужно указать Fortify, как вернуть наш шаблон `two-factor-challenge`. Вся логика визуализации шаблона `two-factor-challenge` Fortify может быть определена с помощью метода `twoFactorChallengeView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::twoFactorChallengeView(function () {
        return view('auth.two-factor-challenge');
    });

    // ...
}
```

Fortify позаботится об определении маршрута `/two-factor-challenge`, который возвращает этот шаблон. Ваш шаблон `two-factor-challenge` должен включать форму, которая делает POST-запрос к конечной точке `/two-factor-challenge`. Действие `/two-factor-challenge` ожидает поле `code`, которое содержит действительный TOTP-токен, или поле `recovery_code`, которое содержит один из кодов восстановления пользователя.

Если попытка входа окажется успешной, то Fortify перенаправит пользователя на URI, указанный в параметре конфигурации `home` файле конфигурации `fortify` вашего приложения. Если запрос на вход был запросом XHR, будет возвращен `204` HTTP-ответ.

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану двухфакторной аутентификации, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.

<a name="disabling-two-factor-authentication"></a>
### Отключение двухфакторной аутентификации

Чтобы отключить двухфакторную аутентификацию, ваше приложение должно сделать DELETE-запрос к конечной точке `/user/two-factor-authentication`. Помните, что конечным точкам двухфакторной аутентификации Fortify перед вызовом требуется [подтверждение пароля](#password-confirmation).

<a name="registration"></a>
## Регистрация

Чтобы начать реализацию функционала регистрации, вам нужно указать Fortify, как вернуть шаблон `register`. Помните, что Fortify – это безголовая библиотека аутентификации. Если вам нужна внешняя реализация функционала аутентификации Laravel, которая уже создана для вас, то вам следует использовать [стартовый комплект приложения](starter-kits.md).

Вся логика визуализации шаблона `register` Fortify может быть определена с помощью метода `registerView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::registerView(function () {
        return view('auth.register');
    });

    // ...
}
```

Fortify позаботится об определении маршрута `/register`, который возвращает этот шаблон. Ваш шаблон `register` должен включать форму, которая выполняет POST-запрос к конечной точке `/register`, определенной Fortify.

Конечная точка `/register` ожидает строковые поля `name`, `email` / `username`, `password` и `password_confirmation`. Имя поля `email` / `username` должно соответствовать значению конфигурации `username`, определенному в файле конфигурации `fortify` вашего приложения.

Если попытка регистрации будет успешной, то Fortify перенаправит вас на URI, настроенный с помощью параметра конфигурации `home` в файле конфигурации `fortify` вашего приложения. Если запрос на вход был запросом XHR, будет возвращен `200` HTTP-ответ.

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану регистрации, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.

<a name="customizing-registration"></a>
### Настройка регистрации

Процесс валидации и создания пользователя можно настроить, изменив действие `App\Actions\Fortify\CreateNewUser`, которое было создано при установке Laravel Fortify.

<a name="password-reset"></a>
## Сброс пароля

<a name="requesting-a-password-reset-link"></a>
### Запрос ссылки для сброса пароля

Чтобы начать реализацию функционала сброса пароля, вам нужно указать Fortify, как вернуть шаблон `forgot-password`. Помните, что Fortify – это безголовая библиотека аутентификации. Если вам нужна внешняя реализация функционала аутентификации Laravel, которая уже создана для вас, то вам следует использовать [стартовый комплект приложения](starter-kits.md).

Вся логика визуализации шаблона `forgot-password` Fortify может быть определена с помощью метода `requestPasswordResetLinkView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::requestPasswordResetLinkView(function () {
        return view('auth.forgot-password');
    });

    // ...
}
```

Fortify позаботится об определении маршрута `/forgot-password`, который возвращает этот шаблон. Ваш шаблон `forgot-password` должен включать форму, которая выполняет POST-запрос к конечной точке `/forgot-password`, определенной Fortify.

Конечная точка `/forgot-password` ожидает строковое поле `email`. Имя этого поля / столбца базы данных должно соответствовать значению конфигурации `email`, определенному в файле конфигурации `fortify` вашего приложения.

<a name="handling-the-password-reset-link-request-response"></a>
#### Обработка ответа на запрос ссылки для сброса пароля

Если запрос ссылки для сброса пароля был успешным, то Fortify перенаправит пользователя обратно на конечную точку `/forgot-password` и отправит пользователю электронное письмо с защищенной ссылкой, которую он может использовать для сброса своего пароля. Если запрос был запросом XHR, будет возвращен `200` HTTP-ответ.

После перенаправления обратно к конечной точке `/forgot-password` после успешного запроса переменная сессии `status` может использоваться для отображения состояния попытки запроса ссылки для сброса пароля. Значение этой переменной сессии будет соответствовать одной из строк перевода, определенных в [языковом файле](localization.md) `passwords` вашего приложения:

```html
@if (session('status'))
    <div class="mb-4 font-medium text-sm text-green-600">
        {{ session('status') }}
    </div>
@endif
```

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану запроса ссылки для сброса пароля, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.

<a name="resetting-the-password"></a>
### Отображение страницы сброса пароля

Чтобы завершить реализацию функционала сброса пароля вашего приложения, вам нужно указать Fortify, как вернуть шаблон `reset-password`.

Вся логика визуализации шаблона `reset-password` Fortify может быть определена с помощью метода `resetPasswordView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::resetPasswordView(function ($request) {
        return view('auth.reset-password', ['request' => $request]);
    });

    // ...
}
```

Fortify позаботится об определении маршрута `/reset-password`, который возвращает этот шаблон. Ваш шаблон `reset-password` должен включать форму, которая выполняет POST-запрос к конечной точке `/reset-password`, определенной Fortify.

Конечная точка `/reset-password` ожидает строковые поля `email`, `password`, `password_confirmation` и скрытое поле с именем `token`, которое содержит значение `request()->route('token')`. Имя поля / столбца базы данных `email` должно соответствовать значению конфигурации `email`, определенному в файле конфигурации `fortify` вашего приложения.

<a name="handling-the-password-reset-response"></a>
#### Обработка ответа на сброс пароля

Если запрос на сброс пароля был успешным, то Fortify перенаправит пользователя обратно на маршрут `/login`, чтобы пользователь мог войти со своим новым паролем. Кроме того, будет установлена переменная сессии `status`, чтобы вы могли отобразить успешный статус сброса пароля на экране входа в систему:

```blade
@if (session('status'))
    <div class="mb-4 font-medium text-sm text-green-600">
        {{ session('status') }}
    </div>
@endif
```

Если запрос был запросом XHR, будет возвращен `200` HTTP-ответ.

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану сброса пароля, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.

<a name="customizing-password-resets"></a>
### Настройка сброса пароля

Процесс сброса пароля можно настроить, изменив действие `App\Actions\ResetUserPassword`, которое было создано при установке Laravel Fortify.

<a name="email-verification"></a>
## Подтверждение адреса электронной почты

После регистрации вы можете пожелать, чтобы пользователь подтвердил свой адрес электронной почты, прежде чем он продолжит взаимодействие с вашим приложением. Для начала убедитесь, что функционал `emailVerification` включен в массиве `features` вашего файла конфигурации `fortify`. Затем вы должны убедиться, что ваш класс `App\Models\User` реализует интерфейс `Illuminate\Contracts\Auth\MustVerifyEmail`.

После завершения этих двух шагов настройки вновь зарегистрированные пользователи получат электронное письмо с предложением подтвердить свой адрес электронной почты. Однако, мы должны сообщить Fortify, как отображать экран подтверждения электронной почты, который информирует пользователя о том, что им нужно перейти по ссылке для подтверждения в электронном письме.

Вся логика визуализации шаблона `verify-email` Fortify может быть определена с помощью метода `verifyEmailView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::verifyEmailView(function () {
        return view('auth.verify-email');
    });

    // ...
}
```

Fortify позаботится об определении маршрута, который отображает этот шаблон, когда пользователь перенаправляется на конечную точку `/email/verify` встроенным в Laravel посредником `verified`.

Ваш шаблон `verify-email` должен включать информационное сообщение, предлагающее пользователю щелкнуть ссылку для подтверждения электронной почты, которая была отправлена на его адрес электронной почты.

<a name="resending-email-verification-links"></a>
#### Повторная отправка ссылок для подтверждения электронной почты

При желании вы можете добавить в шаблон вашего приложения `verify-email` кнопку, которая запускает POST-запрос к конечной точке `/email/verification-notification`. Когда эта конечная точка получает запрос, пользователю будет отправлена новая ссылка для подтверждения электронной почты, позволяющая пользователю получить новую ссылку для подтверждения, если предыдущая была случайно удалена или утеряна.

Если запрос на повторную отправку электронного письма со ссылкой для подтверждения был успешным, Fortify перенаправит пользователя обратно на конечную точку `/email/verify` с переменной сессии `status`, что позволит вам отобразить информационное сообщение для пользователя, информирующее его о том, что операция была выполнена. успешно. Если запрос был запросом XHR, будет возвращен `202` HTTP-ответ.

```blade
@if (session('status') == 'verification-link-sent')
    <div class="mb-4 font-medium text-sm text-green-600">
        Вам отправлена новая ссылка для подтверждения адреса электронной почты!
    </div>
@endif
```

<a name="protecting-routes"></a>
### Защита маршрутов

Чтобы указать, что для маршрута или группы маршрутов требуется, чтобы пользователь подтвердил свой адрес электронной почты, то вы должны назначить маршруту встроенным в Laravel посредника `verify`. Этот посредник зарегистрирован в классе вашего приложения `App\Http\Kernel`:

```php
Route::get('/dashboard', function () {
    // ...
})->middleware(['verified']);
```

<a name="password-confirmation"></a>
## Подтверждение пароля

При создании приложения вы можете потребовать от пользователя подтверждения пароля перед выполнением действия. Как правило, эти маршруты защищены встроенным в Laravel посредником `password.confirm`.

Чтобы начать реализацию функционала подтверждения пароля, вам нужно указать Fortify, как вернуть шаблон `confirm-password`. Помните, что Fortify – это безголовая библиотека аутентификации. Если вам нужна внешняя реализация функционала аутентификации Laravel, которая уже создана для вас, то вам следует использовать [стартовый комплект приложения](starter-kits.md).

Вся логика визуализации шаблона `confirm-password` Fortify может быть определена с помощью метода `confirmPasswordView` класса `Laravel\Fortify\Fortify`. Как правило, вызов этого метода осуществляется в методе `boot` поставщика `App\Providers\FortifyServiceProvider`:

```php
use Laravel\Fortify\Fortify;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Fortify::confirmPasswordView(function () {
        return view('auth.confirm-password');
    });

    // ...
}
```

Fortify позаботится об определении маршрута `/user/confirm-password`, который возвращает этот шаблон. Ваш шаблон `confirm-password` должен включать форму, которая выполняет POST-запрос к конечной точке `/user/confirm-password`, определенной Fortify. Конечная точка `/user/confirm-password` ожидает поле `password`, которое содержит текущий пароль пользователя.

Если пароль совпадает с текущим паролем пользователя, Fortify перенаправит пользователя на маршрут, к которому он пытался получить доступ. Если запрос был запросом XHR, будет возвращен `201` HTTP-ответ.

Если запрос не был успешным, пользователь будет перенаправлен обратно к экрану сброса пароля, и ошибки валидации будут доступны вам через общедоступную [переменную `$errors` шаблонов Blade](validation.md#quick-displaying-the-validation-errors). Или, в случае запроса XHR, ошибки валидации будут возвращены с `422` HTTP-ответом.
